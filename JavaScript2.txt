ðŸ¤” ES 6 feature ?
ðŸ…°ï¸ ES6 (ECMAScript 2015) introduced several new features to JavaScript.

    let and const (Block-scoped Variables)
    let and const provide block-scoping, unlike var, which is function-scoped

    Arrow Functions
    Provides a shorter syntax for functions.

    Template Literals
    Allows embedding expressions inside strings using backticks

    Destructuring Assignment
    Extracts values from arrays or properties from objects

    Default Parameters
    Allows functions to have default values for parameters.

    Spread and Rest Operator (...)
    Spread: Expands an array into individual elements.
    Rest: Gathers arguments into an array.

    Promises
    Handles asynchronous operations

    Modules (import & export)
    Enables modular JavaScript.

    Map and Set
    Map: Key-value pairs with any type as a key.
    Set: Collection of unique values.

    for...of Loop
    Iterates over iterables like arrays, strings, etc.

    ðŸ“Œ ES8 (ECMAScript 2017)
            async/await
            Simplifies asynchronous code using Promise.

    ðŸ“Œ ES11 (ECMAScript 2020)
            Optional Chaining (?.)
            Prevents errors when accessing deeply nested properties.

            Nullish Coalescing (??)
            Returns the right-hand operand if the left-hand operand is null or undefined.

----------------------------------------------------------------------------------------------------------------------------
ðŸ¤” JS Engine ?

ðŸ…°ï¸    "A JavaScript Engine is a program that interprets and executes JavaScript code. 
        It takes human-readable JavaScript code, converts it into machine code, and runs it efficiently."

        Popular JS Engines
            V8 Engine (Google Chrome, Node.js) â€“ Used in Chrome & Node.js
            SpiderMonkey (Mozilla Firefox) â€“ Developed by Mozilla
            JavaScriptCore (WebKit/Safari) â€“ Apple's JS Engine
            Chakra (Microsoft Edge, older version) â€“ Used in older Microsoft Edge versions

----------------------------------------------------------------------------------------------------------------------------
ðŸ¤” TIme & space complexity ?
 
ðŸ…°ï¸     ðŸ“Œ Time complexity != time taken by a piece of code to execute
                Defination =  Rate at which time taken increases w.r.t to input size.

                single loop : O(n)
                nested loop : O(n2)
                nested inside nested loop : O(n3)
                O(log (n))
                O(sqrt n)
    
        ðŸ“Œ space complexity can also be defined by Big O notation,
                Auxiliary space (space that you take to solve the problem) + input space(the space you take to store the input) 

                function sum(a,b){
                        c = a + b 

                        c = Auxiliary space
                        a & b = input space (Never do anything to input space, never manipulate)
                }
----------------------------------------------------------------------------------------------------------------------------
ðŸ¤” type coercin ?

ðŸ…°ï¸ âœ… What is Type Coercion?
        Type Coercion is JavaScript's automatic or implicit conversion of one data type to another.
        JS is dynamically typed, so it tries to coerce values when operands are of different types.

   âœ… How does it happen?
        Implicit => JS auto-converts types during operations (+, ==, etc.)
        Explicit => Developer manually converts types (e.g., Number(), String())

        ðŸ”´ Implicit    '5' + 1     // '51' (number â†’ string)
                        '5' - 1     // 4   (string â†’ number)
                        true + 1    // 2   (boolean â†’ number)
                        null == 0   // false
                        null == undefined // true

        ðŸ”´ Explicit    Number('5');       // 5
                        String(123);       // "123"
                        Boolean(0);        // false

     âš ï¸ Edge / Corner Cases in Type Coercion
             1. + is both numeric and string operator
                       '5' + 1       // "51" (string)
                        5 + '1'       // "51"
                        5 + 1         // 6   (number)
                If either operand is a string, it becomes a string concat!
             
             2. == vs === (loose vs strict equality)
                        '0' == 0      // true  â— (coercion)
                        '0' === 0     // false âœ… (no coercion)
                        false == 0    // true
                        false === 0   // false
                Always prefer === to avoid coercion issues in comparisons.

             3. Falsy values in boolean contexts
                    value -> (0, null, undefined, ' ', Nan)  Boolean conversion -> false
        
             4. null and undefined
                        null == undefined   // true âœ…
                        null === undefined  // false âŒ
                        null == 0           // false
                        undefined == 0      // false
             
             5. NaN (Not a Number)
                         NaN == NaN       // false âŒ
                        isNaN(NaN)       // true âœ…
                 Special case: NaN is not equal to itself.
                 
             ðŸ’¡ Interview Tip:
                â€œType coercion makes JS flexible, but also tricky. I always prefer === and
                explicit conversions (Number(), Boolean(), String()) to avoid unexpected behavior.â€
----------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Deep copy vs shallow copy ?

ðŸ…°ï¸ 
----------------------------------------------------------------------------------------------------------------------------
Q. OOPS, classes, constructor ?

----------------------------------------------------------------------------------------------------------------------------
Q. call, bind & apply ?

Book through hoil
----------------------------------------------------------------------------------------------------------------------------
ðŸ¤” JS Object vs JSON vs REST API ?
ðŸ…°ï¸  JavaScript Object
       defination - A data structure used in JavaScript to store key-value pairs.
       Format -  Uses key-value pairs with functions, variables, etc.
       Data Type - Can store any JS data type (string, number, boolean, array, function, etc.).
       Usage - Used within JavaScript programs for manipulating and storing data.

    JSON (JavaScript Object Notation)
       defination - A lightweight data format for storing and transferring data.
       Format - Purely text-based with key-value pairs in a structured format. 
       Data Type - Only supports string, number, boolean, array, and null.
       Usage - Used for data exchange between web applications and APIs.

       ðŸ’¡ JavaScript to JSON Conversion
          let jsonData = JSON.stringify(person); // Converts JS Object to JSON String
          console.log(jsonData); // {"name":"John","age":30,"isAdmin":true}

        ðŸ’¡ JSON to JavaScript Conversion
            let parsedData = JSON.parse(jsonData); // Converts JSON String back to JS Object
            console.log(parsedData.name); // John


    REST API (Representational State Transfer API)
       defination - A web architecture style used for communication between client and server.
       Format - Uses HTTP methods (GET, POST, PUT, DELETE) to interact with resources. 
       Data Type - Can return JSON, XML, HTML, or other formats.
       Usage - Used to send/receive data between a client and a server.

    How They Are Related
    âœ… JavaScript Objects are used in JavaScript programs for data manipulation.
    âœ… JSON is used to transfer data between JavaScript and APIs.
    âœ… REST APIs often return JSON responses, which JavaScript can parse and use.


----------------------------------------------------------------------------------------------------------------------------
Q.  prototype ?

----------------------------------------------------------------------------------------------------------------------------
Q.  pollyfills ?

----------------------------------------------------------------------------------------------------------------------------
ðŸ¤”  spread vs Rest operator, optional chaining, nullish coalescing operator ?

ðŸ…°ï¸   âœ… 1. Spread Operator (...) - The spread operator expands an iterable (like an array or object) into individual elements.
                                  used in Expanding elements (arrays, objects), Copying arrays/objects, Merging arrays/objects.
            ðŸ‘‰ Example (Array):
                const arr1 = [1, 2, 3];
                const arr2 = [...arr1, 4, 5];
                console.log(arr2); // [1, 2, 3, 4, 5]

            ðŸ‘‰ Example (Object):
                const obj1 = { a: 1, b: 2 };
                const obj2 = { ...obj1, c: 3 };
                console.log(obj2); // { a: 1, b: 2, c: 3 }

             âš ï¸ Corner Cases (Spread):
                   1. Order matters with object spreading:
                        const obj1 = { a: 1, b: 2 };
                        const obj2 = { b: 99, ...obj1 };
                        console.log(obj2); // { b: 2, a: 1 } â€” because `obj1.b` overwrites `b: 99`
                  
                  2. Nested structures are not deep copied:
                        const nested = { a: { inner: 10 } };
                        const copy = { ...nested };
                        copy.a.inner = 99;
                        console.log(nested.a.inner); // 99 â€” shallow copy!

      âœ… 2. Rest Operator (...) - The rest operator collects multiple elements into a single array or object.
                                   Used in function parameters, array destructuring, or object destructuring.

               ðŸ‘‰ Example (Function Parameters):
                       function sum(...nums) {
                        return nums.reduce((acc, val) => acc + val, 0);
                        }

                        console.log(sum(1, 2, 3, 4)); // 10

                ðŸ‘‰ Example (Array Destructuring):
                        const [first, ...rest] = [10, 20, 30, 40];
                        console.log(first); // 10
                        console.log(rest);  // [20, 30, 40]
                
                ðŸ‘‰ Example (Object Destructuring):
                        const { a, ...rest } = { a: 1, b: 2, c: 3 };
                        console.log(a);    // 1
                        console.log(rest); // { b: 2, c: 3 }
                
                âš ï¸ Corner Cases (Rest):
                      1. Rest must be the last in parameter list or destructuring:
                             function test(a, ...rest, b) {} // âŒ SyntaxError

                ðŸ§  Simple Analogy
                        Spread = explode / unpack
                        Rest = collect / pack

        âœ… 3. Optional Chaining (?.) - Optional chaining lets you safely access deeply nested properties without throwing an error 
                                        if an intermediate value is null or undefined.

                 ðŸ‘‰ Example:
                       const user = {
                                name: "Alice",
                                address: {
                                city: "Paris",
                                },
                        };

                        console.log(user?.address?.city);   // "Paris"
                        console.log(user?.contact?.email); // undefined (no error thrown)                       
                        console.log(user.contact.email); // TypeError: Cannot read properties of undefined (reading 'email')

                 âš ï¸ Corner Cases (Optional Chaining):
                       1. Only works with null or undefined â€” not with other falsy values:                    
                                const obj = { val: 0 };
                                console.log(obj?.val); // 0 â€” works fine
                                console.log(obj?.nonExistent?.prop); // undefined

                        2. Doesnâ€™t prevent errors for functions that donâ€™t exist:
                               const user = {};
                                user.sayHi?.(); // âœ… Safe: sayHi doesn't exist
                                user.sayHi();   // âŒ Error: sayHi is not a function

        âœ… 4. Nullish Coalescing (??) - Nullish coalescing returns the right-hand value if the left-hand value is null or undefined, 
                                            otherwise it returns the left-hand value.

                   ðŸ‘‰ Example:
                         const name = null;
                        const finalName = name ?? "Guest";
                        console.log(finalName); // "Guest"

                        const name = null;
                        const finalName =  "Guest" ?? name
                        console.log(finalName); // "Guest"
                 
                   â— Differs from || (logical OR):
                        const count = 0;
                        console.log(count || 10);  // 10   (because 0 is falsy)
                        console.log(count ?? 10);  // 0    (because 0 is NOT null/undefined)

                    ðŸ” Final Rule:
                           a ?? b â†’ return a if a !== null && a !== undefined, otherwise return b.

----------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Destructuring in object & array ?

ðŸ…°ï¸ Destructuring allows you to extract values from arrays or objects into variables in a clean and concise way.

        ðŸ”¹ Object Destructuring

                âœ…const person = { name: "Alice", age: 25 };

                        const { name, age } = person;
                        console.log(name); // "Alice"
                        console.log(age);  // 25

                âœ…const person = { name: "Alice", age: 25, country: "USA" };

                        const { name, ...rest } = person;
                        console.log(rest); // { age: 25, country: "USA" }

        ðŸ”¹ Array Destructuring

                âœ… const numbers = [1, 2, 3];

                        const [first, second] = numbers;
                        console.log(first); // 1
                        console.log(second); // 2

                âœ…const numbers = [1, 2, 3];

                        const [, second, third] = numbers;
                        console.log(second); // 2
                        console.log(third);  // 3

                âœ…const numbers = [1, 2, 3, 4, 5];

                        const [first, ...rest] = numbers;
                        console.log(first); // 1
                        console.log(rest);  // [2, 3, 4, 5]

                âœ… let a = 10, b = 20;
                        [a, b] = [b, a];

                        console.log(a); // 20
                        console.log(b); // 10
----------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Array like objects ? How to convert into Array ?

ðŸ…°ï¸  âœ… What are Array-like Objects?
        Objects that look like arrays but are not real arrays.
        They have:
        Indexed elements (e.g., obj[0], obj[1], ...)
        A length property
        But they do not have array methods like .push(), .map(), .filter(), etc.

     âœ… How to Convert Array-like to Array
          function demo() {
                const argsArray = Array.from(arguments);
                console.log(argsArray);                  // [1,2,3]
                }


                demo(1,2,3)

           function demo() {
                const argsArray = [...arguments];
                console.log(argsArray);
                }

----------------------------------------------------------------------------------------------------------------------------
ðŸ¤” for loop, while loop, Do while, for...of, for...in, forEach loop, map function ?

ðŸ…°ï¸  ðŸ“Œ  for loop
         âœ… What is a for loop in JavaScript?
               A for loop is a control flow statement used to repeat a block of code a specific number of times.
                It is typically used when the number of iterations is known in advance.

        âœ… How does the for loop work?
               for (initialization; condition; increment/decrement) {
                        // code to execute in each iteration
                        }

        âœ… Why use a for loop?
                To perform repetitive tasks efficiently.
                Helps avoid writing repetitive code (e.g., looping through arrays, numbers, or objects).
                Clean, readable, and widely used in iterative logic.

        âœ… When to use a for loop?
                When the number of iterations is known or predictable.
                Example scenarios:
                Iterating over arrays with a known length.
                Running a loop a specific number of times.
                Creating pattern-based outputs (e.g., multiplication tables).

    ðŸ“Œ  while loop
          If I donâ€™t know the number of iterations in advance and the loop depends on dynamic data or an external event, Iâ€™d use a while loop.
           For example, when polling an API until it returns a success response."

        âœ… What is a while loop in JavaScript?
                A while loop is a control flow statement that executes a block of code as long as a specified condition is true.
                Unlike a for loop, it is used when the number of iterations is not known in advance.
        
        âœ… How does the while loop work?
                while (condition) {
                        // code to execute repeatedly
                        }

                Condition: Checked before each iteration.
                If the condition is true â†’ executes the loop body.
                Must manually update loop variables to avoid infinite loops.

        âœ… Why use a while loop?
                Useful when we don't know beforehand how many times we need to loop.
                Gives more flexibility compared to a for loop.
                Especially handy when waiting for a condition to become false (like user input, API retries, or reading data until the end).

        âœ… When to use a while loop?
                When the termination condition depends on dynamic data.
                When you need to loop until a certain event or condition occurs.
                Example scenarios:
                Reading a file line by line.
                Retrying a network request until it succeeds.
                Waiting for user input to meet certain criteria.

      ðŸ“Œ Do...while
             A while loop may never run if the condition is false initially. But in some cases, 
             like collecting user input or initiating a retry logic,
              we want to ensure the logic runs once before checking the condition â€” thatâ€™s where do...while is more suitable.

        âœ… What is a do...while loop in JavaScript?
                A do...while loop is a control flow statement that executes a block of code at least once,
                then repeats execution as long as the condition is true.
                It is the only loop in JS that guarantees at least one execution, regardless of the condition.
        
        âœ… How does the do...while loop work?
                do {
                    // code block to execute
                      } while (condition);

                Flow:
                Execute block once.
                Check the condition.
                If condition is true, loop again. Otherwise, stop.

        âœ… Why use a do...while loop?
                To ensure the loop body runs at least once, even if the condition is false.
                It's useful when the initial action must happen before validating the condition, like:
                Prompting a user for input.
                Initializing resources before checking.

        âœ… When to use a do...while loop?
                When the loop must execute at least once, regardless of the condition.
                Common scenarios:
                User input validation.
                Menu systems in CLI tools.
                Retrying logic where the first attempt must always happen.

      ðŸ“Œ for...of
            "for...of is ideal when you just want to read values from an iterable.
             Itâ€™s cleaner than for and doesnâ€™t require managing indexes.
             Unlike forEach, it also supports break, continue, and return, making it more flexible in some scenarios."

             âœ… What is a for...of loop in JavaScript?
                The for...of loop is used to iterate over iterable objects like arrays, strings, maps, sets, etc.
                Introduced in ES6, it provides a clean and readable syntax for accessing elements directly.

             âœ… How does the for...of loop work?
                for (const element of iterable) {
                        // code to execute for each element
                        }

                const colors = ['red', 'green', 'blue'];
                        for (const color of colors) {
                        console.log(color);
                        }

                for (const char of "hello") {
                        console.log(char);
                        }

              âœ… Why use a for...of loop?
                Simplicity & readability: You donâ€™t need to deal with index or .length.
                Avoids off-by-one and index-related bugs.
                Works well when you only care about the values, not the indexes/keys.
        
              âœ… When to use a for...of loop?
                When iterating over:
                Arrays (e.g., list of items)
                Strings (e.g., processing characters)
                Sets (unique values)
                Maps (with destructuring)
                Arguments object
                Generators & custom iterables
                Use when you donâ€™t need the index or key, just the value.

      ðŸ“Œ for...in
             "I use for...in when I want to iterate through all enumerable properties of an object,
              but I always pair it with hasOwnProperty() to avoid inherited properties. 
              For arrays or iterable values, I prefer for...of for safety and readability."

              âœ… What is a for...in loop in JavaScript?
                The for...in loop is a control structure used to iterate over the enumerable property keys (names) of an object.
                It iterates over keys, not values, and is most commonly used with objects.

             âœ… How does the for...in loop work?
                const user = {
                        name: "Alice",
                        age: 25,
                        city: "Mumbai"
                        };

                        for (const key in user) {
                        console.log(key, user[key]);
                        }

                        output: name Alice
                                age 25
                                city Mumbai

                âœ… Why use a for...in loop?
                        It's best for enumerating keys of an object.
                        Helps in dynamically accessing or processing object properties.
                        Especially useful when the object structure is not fixed or known in advance.

                âœ… When to use a for...in loop?
                        When you need to:
                        Access all property keys of an object (including inherited enumerable ones).
                        Loop through object keys for validation, transformation, or logging.
                        Use it cautiously with arrays or custom objects.
                
      ðŸ“Œ forEach
           "forEach() is great for performing side effects on every element in an array,
            like logging or updating UI. But I avoid it when I need to break early or work with asynchronous code â€” 
            then I switch to for...of for more control."

          âœ… What is forEach() in JavaScript?
                forEach() is a built-in array method in JavaScript.
                It executes a provided callback function once for each element in an array, in order.
                It's a way to loop through arrays, without needing to manage indexes manually.
          
          âœ… How does forEach() work?
               const fruits = ['apple', 'banana', 'mango'];

                fruits.forEach((fruit, index) => {
                    console.log(index, fruit);
                });

                0 apple
                1 banana
                2 mango
           
           âœ… Why use forEach()?
                Cleaner and more readable than traditional for loops.
                Avoids manual handling of loop counters or array length.
                Ideal for performing side-effects like logging, updating DOM, or modifying external variables.

            âœ… When to use forEach()?
                When you need to:
                Iterate over all items in an array.
                Apply a function to each item (like logging, transforming, validating).
                Avoid using break, continue, or return to exit early.
                Best used when you want to go through the whole array.

      ðŸ“Œ map 
           Already Done
------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” syntax error, referenece error, TypeError, range error ?

ðŸ…°ï¸     âœ… Syntax Error
                When? Happens when the JavaScript code is not written correctly (violates language rules).
                Why? The interpreter is unable to parse the code.

        âœ… Reference Error
                When? Occurs when trying to use a variable that hasnâ€™t been declared.
                Why? The variable is undefined or does not exist in the current scope.

        âœ… Type Error
                When? Happens when performing an operation on a value of the wrong type.
                Why? Youâ€™re trying to use a method or property that does not exist on that type.

        âœ… Range Error
                When? Occurs when a value is outside the allowed range.
                Why? Examples include calling functions with invalid arguments.

-------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” throw statement, try {} catch(){ }, finally{ }

ðŸ…°ï¸     "throw, try...catch, and finally help us manage errors in JavaScript. 
        try runs risky code, catch handles any thrown errors,
        and finally always runs â€” even if thereâ€™s an error. This is crucial for maintaining robust, 
        crash-proof applications."

        âœ… What is Error Handling in JavaScript?
                In JavaScript, error handling allows you to catch and handle runtime errors gracefully,
                instead of crashing your application.

        âœ… throw Statement
                ðŸ”¹ What it does:
                The throw statement manually throws an error. You can throw:
                A built-in error object (new Error("message"))
                A string, number, boolean, or any expression

        ðŸ‘‰ Example
        function divide(a, b) {
                if (b === 0) {
                        throw new Error("Cannot divide by zero!");
                }
                        return a / b;
                }

        âœ… try...catch Block
                ðŸ”¹ What it does:
                Used to handle errors that occur in the try block. If an error occurs,
                control is passed to the catch block.

        ðŸ‘‰ Example
                try {
                        const result = divide(10, 0);
                        console.log(result);
                } catch (error) {
                        console.error("Caught an error:", error.message);
                        }

        âœ… finally Block
                ðŸ”¹ What it does:
                The finally block is optional and always runs â€” whether thereâ€™s an error or not.
                Used for cleanup code like closing connections or hiding loading indicators.

        ðŸ‘‰ Example
                function fetchUserData() {
                        try {
                                // Imagine calling an API
                                throw new Error("Network error!");
                                } catch (err) {
                                console.log("Something went wrong:", err.message);
                                } finally {
                                console.log("Closing loading spinner...");
                                }
                        }
                        fetchUserData();

-------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” CSR vs SSR vs SSG vs ISR ?

ðŸ…°ï¸ "CSR renders on the browser, SSR on the server per request, SSG at build time, 
        and ISR is like SSG but can regenerate pages dynamically. 
        Choosing between them depends on factors like SEO, performance, content freshness, and interactivity."

    CSR	Client-Side Rendering	Content is rendered in the browser using JavaScript. HTML is minimal at first.
    SSR	Server-Side Rendering	Page is rendered on the server for each request and sent to the client as HTML.
    SSG	Static Site Generation	Pages are pre-rendered at build time into static HTML files.
    ISR	Incremental Static Regeneration	Pages are pre-rendered and updated on demand in the background. Combines SSG + SSR benefits.

        CSR:     Build -> Blank HTML -> JS runs -> Page rendered in browser
        SSR:     Request -> Server renders HTML -> Page sent to browser
        SSG:     Build -> HTML generated -> Served from CDN
        ISR:     Build -> HTML + revalidate time -> Background rebuild on request

         CSR:
         when -> - SPAs - User interaction-heavy apps
         why -> - Great for interactivity - Low server cost
         
         SSR:
         when -> - Dynamic pages (e.g. user dashboards) - SEO needed
         why -> - Better SEO than CSR - Fresh data on each load

         SSG:
         when -> - Blogs - Docs - Marketing sites
         why -> - Super fast - CDN-friendly - Best for static content

         ISR:
         when -> - Product pages - News articles - Large sites with some changing content
         why -> - Combines speed of SSG + freshness of SSR - Partial rebuilds = scalable


-------------------------------------------------------------------------------------------------------------------------------------


🤔 Execution context & call stack ?
🅰️  📌 Why (Why do we need Execution Context & Call Stack?)
        JavaScript is a single-threaded language, meaning it executes one operation at a time.
         To efficiently manage function execution and keep track of which function is currently running, 
         JavaScript uses Execution Context and Call Stack.
        Without them, JavaScript wouldn't know which function to execute next or how to maintain function scopes.

    📌 How (How does Execution Context & Call Stack work?)
            Execution Context
            When JavaScript executes a script, it creates an Execution Context to manage the execution of code.

            Each Execution Context has two phases:
            1️⃣ Creation Phase

                Creates the Variable Environment (stores variables & functions).
                Sets up the Lexical Environment (scopes & references).
                Sets this keyword based on the context.

            2️⃣ Execution Phase

                Assigns values to variables.
                Executes function calls & statements.

            Call Stack
            The Call Stack is a stack data structure that follows LIFO (Last In, First Out) to manage function execution.

            When a function is called, its Execution Context is pushed onto the Call Stack.
            When the function completes, it is popped off the stack.
            If a function calls another function, the new function’s Execution Context is pushed on top.

            Example : function first() {
                            console.log("First Function");
                            second();
                        }
                        function second() {
                            console.log("Second Function");
                            third();
                        }
                        function third() {
                            console.log("Third Function");
                        }
                        first();

            Call Stack Flow:

                first() is called → first Execution Context is pushed.
                Inside first(), second() is called → second Execution Context is pushed.
                Inside second(), third() is called → third Execution Context is pushed.
                third() completes → Removed from the stack.
                second() completes → Removed from the stack.
                first() completes → Removed from the stack.
                The stack is now empty.

    📌 What of execution context & call stack ?
    
    The Execution Context manages function execution (GEC, FEC).
    The Call Stack maintains the order of function calls.

    ⚠️ Edge Cases / Corner Cases

        Stack Overflow (Infinite Recursion)
        Asynchronous Functions & Call Stack : JavaScript uses the Event Loop & Callback Queue for asynchronous operations.
        Lexical Scope & Closures : Nested functions can retain access to outer function variables.
----------------------------------------------------------------------------------------------------------------------------
🤔 Hoisting var, let, const, temporal dead zone ?
 
🅰️ Hoisting:- By which you can access variable & functions even before you have initialized it or you have put some value in it,
                you can access it without any error.

                ✅ code snippet 1
                      var x = 7

                        function getName(){
                            console.log("Namaste Javascript")
                        }

                        getName()
                        console.log(x)    

                        output :
                        Namaste Javascript
                        7

                ✅ code snippet 2

                        getName()
                        console.log(x)

                        var x = 7

                        function getName(){
                            console.log("Namaste Javascript")
                        }

                          output :
                          Namaste Javascript
                          undefined

                ✅ code snippet 3

                          getName()
                          console.log(x)

                          function getName(){
                              console.log("Namaste Javascript")
                          }

                          output :
                          Namaste Javascript
                          ReferenceError: x is not defined

                ✅ code snippet 4

                          var x = 7

                            function getName(){
                                console.log("Namaste Javascript")
                            }

                            console.log(getName)

                            or 

                              console.log(getName)

                              var x = 7

                              function getName(){
                                  console.log("Namaste Javascript")
                              }


                            output :
                            ƒ getName(){
                                  console.log("Namaste Javascript")
                              }



                ✅ code snippet 5

                              getName()
                              console.log(x)
                              console.log(getName)

                              var x = 7

                              function getName(){
                                  console.log("Namaste Javascript")
                              }

                               output :
                               Namaste Javascript
                                undefined
                                ƒ getName(){
                                  console.log("Namaste Javascript")
                              }


                ✅ code snippet 6

                                  getName()
                                  console.log(x)
                                  console.log(getName)

                                  var x = 7

                                  var getName = ()=> {   
                                      console.log("Namaste Javascript")
                                  }

                                   output :
                                   TypeError: getName is not a function
                                   Reason = In this getName is arrow function, so here it behaves like a variable,
                                            so in memory creation getName = undefined 

                ✅ code snippet 7

                                  getName()
                                  console.log(x)
                                  console.log(getName)

                                  var x = 7

                                  var getName = function() {   
                                      console.log("Namaste Javascript")
                                  }

                                  output :
                                   TypeError: getName is not a function
                                   Reason = In this getName is arrow function, so here it behaves like a variable,
                                            so in memory creation getName = undefined 

                ✅ code snippet 8

                                    getName()
                                    console.log(x)
                                    console.log(getName)

                                    var x = 7

                                    function getName() {
                                        console.log("Namaste Javascript")
                                    }

                                    output :
                                    Namaste Javascript
                                    undefined
                                    ƒ getName(){
                                        console.log("Namaste Javascript")
                                    }

                ✅ code snippet 9
                                  
                                  var name = "vinod"
                                  console.log(name)      // vinod

                                  let name = "bahadur"
                                  console.log(name)      // bahadur

                                  const name = "thapa"
                                  console.log(name)      // thapa

                ✅ code snippet 10
                                  
                                  var name = "vinod"
                                  var name = "thapa"
                                  console.log(name)      // thapa

                                  let name = "vinod"
                                  let name = "thapa"
                                  console.log(name)      // SyntaxError: Identifier 'name' has already been declared
                                  // you can declare the same variable using "let" more than once in the same scope

                                   let name = "vinod"
                                  name = "thapa"
                                  console.log(name)       // thapa

                                  const name = "vinod"
                                  const name = "thapa"
                                  console.log(name)       // SyntaxError: Identifier 'name' has already been declared

                                  const name = "vinod"
                                   name = "thapa"
                                  console.log(name)       // TypeError: Assignment to constant variable.

                ✅ code snippet 11

                                  function modJS(love){
                                    if(love){
                                        let name = "vinod"
                                        const sname = "thapa"
                                        console.log(name + sname)     // vinodthapa
                                    }                                  
                                  }
                                  
                                  modJS(true)


                                  function modJS(love){
                                    if(love){
                                        var name = "vinod"
                                        var sname = "thapa"
                                        console.log(name + sname)     // vinodthapa
                                    }                                  
                                  }
                                  
                                  modJS(true)


                                  function modJS(love){
                                    if(love){
                                        var name = "vinod"
                                        var sname = "thapa"                                        
                                    }      
                                    console.log(name + sname)     // vinodthapa                            
                                  }
                                  
                                  modJS(true)


                                  function modJS(love){
                                    if(love){
                                        let name = "vinod"
                                        const sname = "thapa"                                        
                                    }      
                                    console.log(name + sname)     // ReferenceError: name is not defined                           
                                  }
                                  
                                  modJS(true)

                ✅ code snippet 12

                                  var whoWins = "India"

                                    if(true){
                                        var whoWins = "NZ"
                                        console.log(whoWins)       // NZ
                                    }
                                    console.log(whoWins)            // NZ


                                  let whoWins = "India"

                                    if(true){
                                        let whoWins = "NZ"
                                        console.log(whoWins)       // NZ
                                    }
                                    console.log(whoWins)            // India


                                  const whoWins = "India"

                                    if(true){
                                        const whoWins = "NZ"
                                        console.log(whoWins)       // NZ
                                    }
                                    console.log(whoWins)            // India

                  ✅ code snippet 13

                                    console.log(b)        // undefined
                                      let a = 100
                                      var b = 100

                                    console.log(a)        // ReferenceError: Cannot access 'a' before initialization
                                      let a = 100
                                      var b = 100
                                    
                                      let a = 100
                                      console.log(a)        // 100
                                      var b = 100

  Temporal Dead Zone = is the time since when this, let a / const xyz was hoisted & till it is initialised same value.
                          time btn both of this id known as "temporal dead zone"

                          whenever you access a variable in temporal dead zone it throws "Reference error"

                          both, let a & var b memory was allocated but var b was attached to global object,
                          let a & const xyz they are also allocated memory & that is what is called Hoisting,
                          but, they are stored in diff memory space & you cannot access this memory space before you
                          have put any value in them/ Initialised/ decalred. 
                                
                 ✅ code snippet 14

                                    console.log(x)      // ReferenceError: x is not defined
                                    let a = 100
                                    var b = 100

                                    let a = 10
                                    let a = 100
                                    console.log(a)      // SyntaxError: Identifier 'a' has already been declared

                                    let a = 10
                                    let a = 100
                                    console.log(a)      // SyntaxError: Identifier 'a' has already been declared
                                    
                                    let a = 10
                                     a = 100
                                    console.log(a)      // 100

                                   let a = 10
                                    var b =  100
                                    var b = 1000
                                    console.log(b)     // 1000

                                    let a                    -> declare
                                    const b =  100
                                    a = 1000                  -> Initialize
                                    console.log(a)      // 1000

                                    const b;
                                    b = 1000
                                    console.log(b)     // SyntaxError: Missing initializer in const declaration

                                    const b = 10
                                    b = 1000
                                    console.log(b)    // TypeError: Assignment to constant variable.

                                    const b = 1000
                                    console.log(b)     // 1000

                  ✅ code snippet 15
                                    {
                                      var a = 10;  // a hoisted in global space
                                      let b = 20;  // b & c are hoisted in different memory space
                                      const c =30
                                      
                                      console.log(a)      // 10
                                      console.log(b)      // 20
                                      console.log(c)      // 30
                                  }

                                  console.log(a)      // 10
                                  console.log(b)      ReferenceError: b is not defined
                                  console.log(c)  

                  ✅ code snippet 16  (shadowing in JS)

                                    var a = 100; (both var a, are pointing to same global scope)
                                      {
                                          var a = 10;
                                          let b = 20;
                                          const c = 30;
                                          console.log(a)      // 10
                                      }
                                      console.log(a)          // 10

                                      let b = 100;     // here b has a script scope
                                          {
                                              var a = 10;    //  here a has global scope
                                              let b = 20;    // here b has block scope
                                              const c = 30;  // here c has block scope
                                              console.log(b)    // 20
                                          }
                                          console.log(b)      // 100

                                      const c = 100;
                                            {
                                                var a = 10;
                                                let b = 20;
                                                const c = 30;
                                                console.log(c)    // 30
                                            }
                                            console.log(c)        // 100


                                        const c = 100;
                                            function x(){
                                                const c = 30
                                                console.log(c)    // 30
                                            }

                                            x()
                                            console.log(c)          // 100

                    ✅ code snippet 16  (illegal shadowing in JS)

                                        var a = 20
                                        {
                                          var a = 20   ✅
                                        }


                                        let a = 20
                                        {
                                          var a = 20   ❌  // syntax error : Identifier a is already been declared.
                                          var crossing this block scope interfying with let, var is always attached to 
                                          global scope, no matter where it is declare & also var is a function scope.
                                        }

                                        let a = 20
                                        function x(){
                                          var a = 20          ✅
                                        }

                                        let a = 20;
                                        {
                                          let a = 20;         ✅
                                        }


                                        var a = 20;
                                        {
                                          let a = 20;         ✅
                                        }

                      ✅ code snippet 17

                                        const a = 20
                                            {
                                                const a = 100
                                                {
                                                    const a = 200
                                                    console.log(a)    // 200
                                                }
                                            }
                                      

                                      const a = 20
                                            {
                                                const a = 100
                                                {
                                                    const a = 200
                                                    
                                                }
                                                console.log(a)          // 100
                                            }


                                      const a = 20
                                            {
                                                const a = 100
                                                {
                                                    console.log(a)          // 100    
                                                }         
                                            }

                                       const a = 20
                                            {
                                                const a = 100
                                                {
                                                    const a = 200
                                                }
                                            }
                                                console.log(a)         // 20

----------------------------------------------------------------------------------------------------------------------------
🤔 Window & this keyword ?

🅰️  📌 <script>  👀
            // If you are running JS in browsers, the global object is "window",
            // In nodejs env, the global object is "global" or "globalThis"

            console.log(this) //window -> Alone, this refers to the global object, 

            function sum(){
                var add = 2 + 2
                console.log(add)  // 4
                console.log(this)  // window -> In a method, this refers to the global object.
            }

                sum()
        </script>

    📌 <script> 👀
            const thapa = {
                name: "vinod thapa",
                qualif: "MCS",
                sum: function () {
                var add = 2 + 2;
                console.log(add);    // 4
                console.log(this);   //  {name: 'vinod thapa', qualif: 'MCS', sum: ƒ}
                // In a method, this refers to the owner object
                
                console.log(this.name);   // vinod thapa
                },
            };

            thapa.sum()
         </script>

    📌 <script>  👀
      "use strict";

            function sum() {
                var add = 2 + 2;
                console.log(add); // 4
                console.log(this); //  undefined
                // In a function, in "strict mode", this is undefined
            }

            sum();
        </script>

    📌 <script> 👀
          "use strict";

                function x() {
                    console.log(this)    // undefined
                }
                
                x()
        </script>

    📌 <script> 👀
            function x() {
                console.log(this)    // window
            }

      // If the value of this keyword is undefined or null, this keyword will be replaced with "global object"
      //  here, In browser it is "window".
       
      x()
        </script>


    📌 <script>  👀
         "use strict";

            function x(){
                console.log(this)  // undefined
            }

            x()
            window.x()  // window

        "use strict" -> advantage -> Debugging error is Simple

        strict mode characteristics :
        1. Duplicate arguments are not allowed by Developers.
        2. Developers are not allowed to create global variables.

        </script>


    📌 <script> 👀

        const student = {
            name: "Akshay",
            printName : function(){
                console.log(this.name)   // Akshay
            }
        }

        student.printName()

        const student2 = {
            name : "prashant"
        }

        student2.printName()    // Uncaught TypeError: student2.printName is not a function

        </script>


    📌 <script>  👀

        const student = {
            name: "Akshay",
            printName : function(){
                console.log(this.name)
            }
        }

        student.printName()   // Akshay

        const student2 = {
            name : "prashant"
        }

        student.printName.call(student2)   // prashant
        // call, apply, bind, are important functions used to manupilate the value of "this", or overwrite
            the value of "this", when calling methods & sharing them between objects.

        </script>

    📌 <script> 👀
      // this inside arrow function
      // Arrow function do not have their own "this" binding and take the value of the enclosing lexical context,
      //  often the global space

            "use strict" or do not use "use strict", answer is same

            const obj = {
                a: 10,
                x: () => {
                console.log(this); // window
                },
            };

            obj.x();
    </script>

    📌  <script> 👀
          // this inside nested arrow function.
                "use strict" or do not use "use strict", answer is same

            const obj = {
                a: 10,
                x: function() {
                const y = () =>{
                    console.log(this)   // {a: 10, x: ƒ}
                }
                y()
                },
            };

            obj.x();
    </script>

    📌      <script> 👀

                function x(){
                const y = () =>{
                        console.log(this)    // window object

                    }
                    y()
                }

                x()
    </script>


    📌 <script> 👀
                "use strict" 

                function x(){
                const y = () =>{
                        console.log(this)    // undefined
                    }
                    y()
                }

                x()
      </script>

    📌<script> 👀
                "use strict";

                function x(){
                const y = () =>{
                        console.log(this)    // window object
                    }
                    y()
                }

                window.x()
       </script>  

    
----------------------------------------------------------------------------------------------------------------------------
🤔 undefined vs not defined vs null ?
🅰️   📌 why ?
        JavaScript has multiple ways to represent missing or uninitialized values,
        and understanding the differences between them helps in debugging and avoiding runtime errors. 
        Using the wrong type can lead to unexpected behaviors.

    📌 how ?
        ✅undefined
        A variable is declared but not assigned a value.
        Functions without a return statement return undefined by default.
        Accessing an object property that doesn’t exist returns undefined.

        ✅not defined
        A variable is not declared at all.
        Accessing a variable that has never been declared will throw a ReferenceError.

        ✅null
        null is an explicit assignment to indicate "no value".
        It must be manually assigned to a variable.
        Often used to reset a variable or indicate missing values in databases.

        🔥 Edge Cases / Corner Cases

            console.log(typeof undefined); // "undefined"
            console.log(typeof null); // "object" (historical JS bug)
            console.log(typeof x); // "undefined" (if declared but uninitialized)
            console.log(typeof notDeclaredVariable); // "undefined" (no ReferenceError)

            The reason typeof notDeclaredVariable returns "undefined" instead of throwing a ReferenceError is due to ECMAScript specification design.
            This behavior was intentionally introduced to make JavaScript more fault-tolerant.

            Early versions of JavaScript needed fault tolerance

            In early JavaScript implementations, encountering an undeclared variable would have caused a crash.
            Allowing typeof to return "undefined" instead of throwing an error prevented unnecessary runtime failures.

            console.log(typeof undeclaredVar); // ✅ "undefined"
            console.log(undeclaredVar); // ❌ ReferenceError: undeclaredVar is not defined



            console.log(null == undefined); // true (loose equality)
            Because JavaScript considers them both "empty" values and treats them as equal in loose comparisons.
            console.log(null === undefined); // false (strict equality)
            console.log(null == false); // false
            console.log(undefined == false); // false
            console.log(null == 0); // false
            console.log(undefined == 0); // false

            JSON.stringify({ a: null, b: undefined });    // '{"a":null}' (undefined is removed!)
           

----------------------------------------------------------------------------------------------------------------------------
🤔 scope, scope chain, lexical env ?

🅰️  Scope : means you can access a specific variable or function in our code.
     Scope chain : chain of lexcial env & parent references
     lexcial env : local memory + reference to the lexical Environment

     pak <- Ind  (Inside out value searching, OK)✅
     pak -> Ind  (Outside In value searching, Not OK)❌

     ✅ code snippet 1

                  function a(){
                        console.log(b)     // 10
                    }

                    var b = 10
                    a()

      ✅ code snippet 2

                    var b = 10
                      function a(){
                          var x = 100
                          
                      }
                      console.log(b)      // 10
                      console.log(x)      // ReferenceError: x is not defined
                      a()

       ✅ code snippet 3

                          function a(){
                              c()
                              function c(){
                                  console.log(b)   // 10
                              }
                              
                          }
                          var b = 10
                          a()

       ✅ code snippet 4

                          function a(){
                            var b = 10
                              c()
                              function c(){
                                  console.log(b)   // 10
                              }
                              
                          }
                          
                          a()
          
       ✅ code snippet 5

                          function a(){
                            var b = 10
                              c()
                              function c(){
                                  
                              }
                              
                          }
                          
                          a()
                          console.log(b)   // ReferenceError: b is not defined
          
----------------------------------------------------------------------------------------------------------------------------
🤔 function scope, block scope, global scope ?

🅰️  var is function scoped
    let & const is block scoped

    In JavaScript, variables have three types of scope: Global Scope, Function Scope, and Block Scope. 
    Global variables can be accessed anywhere, Function Scope means a variable is accessible only inside a function, 
    and Block Scope applies to variables declared inside {} using let or const.

    Edge Case: If a global variable is declared using var, it will be added to the window object in browsers.
    Edge Case: If a variable is declared with var inside a function, it will still have function scope but will 
                not be block-scoped inside loops or conditionals.
    

      var inside a block still has function scope, not block scope
          function test() {
          if (true) {
              var x = 10;
          }
          console.log(x); // ✅ Works! (Function Scoped)
          }
          test();


      let and const respect block scope
            function test() {
            if (true) {
                let y = 20;
            }
            console.log(y); // ❌ ReferenceError: y is not defined
        }
        test();
----------------------------------------------------------------------------------------------------------------------------
🤔 Difference  between closure and scope ?
🅰️  ✅ Scope:
        Scope determines where variables are accessible in your code. It defines the lifetime and visibility of a variable.
        Global Scope → Variables declared outside any function are accessible everywhere.
        Function Scope → Variables declared inside a function are only accessible within that function.
        Block Scope (Introduced with let & const) → Variables inside {} blocks are limited to that block.

    ✅ Closure:
        A closure is a function that remembers the variables from its parent scope, even after the parent function has executed.
        Closures help in data encapsulation and creating private variables.
        It allows functions to maintain state between executions.

    🔥 Edge Cases / Corner Cases
         🔹   Edge Case 1: Closure Retaining Stale Data, Issue: Each instance of createCounter() has its own closure.

                    function createCounter() {
                    let count = 0;
                    return function () {
                        count++;
                        return count;
                    };
                    }

                const counter1 = createCounter();
                const counter2 = createCounter();

                console.log(counter1()); // 1 (same closure share state)
                console.log(counter1()); // 2

                console.log(counter2()); // 1 (Separate closure, doesn't share state)

          🔹 Edge Case 2: Loop with var in Closures

                    for (var i = 0; i < 3; i++) {
                        setTimeout(() => console.log(i), 1000);
                    }

                    3
                    3
                    3
         
                    Because var is function-scoped, so the final value of i (which is 3) is used for all closures.


          
----------------------------------------------------------------------------------------------------------------------------
Q. closures, closures with setTimeout, setInterval, Tust Issues with setTimeout ?

Book through hoil

----------------------------------------------------------------------------------------------------------------------------
🤔 Normal function vs arrow function ?

🅰️    ✅ code snippet 1  (normal function/ function statement/ function declaration)
            a()   ✅
           function a(){
                console.log("a called")
            }

      ✅ code snippet 2  (arrow function/ function expression/ function acts like a value)

              b()      ❌
              var b = function(){
                    console.log("b callled")      // TypeError: b is not a function 
                }

              ba()     ❌
              var ba = ()=>{
                  console.log("b callled")
              }

              

        Difference btn code snippet 1 & 2 is "Hoisting", code snippet 2 behave like a variable having a value.
        see the function calling position in both the code snippet.
----------------------------------------------------------------------------------------------------------------------------
🤔. types of function ?
🅰️  🔴Void function: functions which does not return anything, they just display value.
     🔴anonymous Function

        eg: function(){
                  
                }

    🔴first class function (eg: shown in respective question )
    🔴call back function  (eg: shown in respective question )
    🔴Higher order function  (eg: shown in respective question )
    🔴arrow function (eg: shown in respective question )
    🔴pure function  (eg: shown in respective question )
    🔴function statement == function declaration (eg: shown in respective question )
    🔴function expression (eg: shown in respective question )
    🔴Named function expression

        eg: var b = function xyz(){
                    console.log("function called")
                }

                b()
                xyz()    // ReferenceError: xyz is not defined


        eg: var b = function xyz(){
                    console.log(xyz)     // ƒ xyz(){
                                         //  console.log(xyz)
                                         //    }
                  }

                 b() 



----------------------------------------------------------------------------------------------------------------------------
🤔 How many ways you can pass arguments to the functions ?
🅰️   ✅ Positional Arguments
            Arguments are passed based on the position they appear in the function call.
            The first value goes to the first parameter, second to the second, and so on.

                function add(a, b) {
                    return a + b;
                    }
                    add(2, 3); // 2 is assigned to a, 3 to b

      ✅ Default Parameters - Used to provide default values for parameters if no argument (or undefined) is passed.
                 
                 function greet(name = "Guest") {
                    console.log(`Hello, ${name}`);
                    }
                    greet();       // Hello, Guest
                    greet("Sam");  // Hello, Sam

        ✅  Rest Parameters - Allows a function to accept an indefinite number of arguments as an array. Syntax: ...rest

                    function sum(...numbers) {
                        return numbers.reduce((a, b) => a + b, 0);
                        }
                        sum(1, 2, 3); // 6

        ✅ Arguments Object
                An array-like object available inside functions (non-arrow functions).
                Contains all arguments passed to the function, regardless of the defined parameters.
                ❌ Not allowed in arrow function.
                
                It's a built-in object available inside non-arrow functions.
                It contains an array-like collection of all arguments passed to the function, regardless of how many parameters the function declares.

                function showArguments() {
                    console.log(arguments);       // [Arguments] { '0': 'apple', '1': 'banana', '2': 'cherry' }
                    }

                    showArguments("apple", "banana", "cherry");


                function showArgs() {
                    for (let i = 0; i < arguments.length; i++) {
                        console.log(arguments[i]);
                    }
                    }
                    showArgs("a", "b", "c");

        ✅  Object as Parameter (Named Arguments)
                A single object is passed to the function with named properties.
                Useful for functions with many optional parameters.

                function createUser({ name, age }) {
                    console.log(name, age);
                    }
                    createUser({ name: "John", age: 25 });

        ✅  Array as Parameter
                Pass an array directly and access values via indexing or destructuring.

                function processData([a, b]) {
                        console.log(a, b);
                        }
                        processData([10, 20]); // 10 20

        ✅ Function as Argument (Callback)
                Functions can accept other functions as arguments and invoke them.

                function executor(callback) {
                        callback();
                        }
                        executor(() => console.log("Hello from callback"));

-----------------------------------------------------------------------------------------------------------------------------
🤔 How to use default parameters in function ?

🅰️ Alraedy Done.
------------------------------------------------------------------------------------------------------------------------------
🤔 pure vs Impure function ?

🅰️     ✅ Pure Functions

            Always returns the same output for the same input.
            Does not cause any side effects (e.g., modifying global variables, DOM, files, etc.).

            characteristics:
            Deterministic: Same input → Same output.
            No side effects: Doesn’t change external state.
            Testable and predictable.

              function add(a, b) {
                    return a + b;
                    }

            add(2, 3) will always return 5, no matter when or where it's called.

        ✅ Impure Functions

              May return different outputs for the same inputs.
              Causes side effects — like modifying external variables, I/O, or state.

               Side Effects Examples:
                    Changing a global variable
                    Logging to console
                    Writing to a file or DB
                    Fetching API data
                    Modifying DOM

                let count = 0;
                    function increment() {
                    count++;
                    return count;
                    }

                Calling increment() will give different results each time because it mutates external state (count).

                function getDate() {
                    return new Date();
                    }

                Seems pure, but returns different output every time → impure.

                function square(x) {
                    console.log(x); // side effect
                    return x * x;
                    }

                Output is consistent, but console.log is a side effect → impure.

                function double(arr) {
                    arr[0] = arr[0] * 2;
                    return arr;
                    }

                Modifies input array → side effect → impure.

                function getRandom() {
                    return Math.random();
                    }

                Non-deterministic output → impure.

            ✅ Bonus Tip: How to Spot a Pure Function?

                Ask yourself:
                ❓ Does it depend only on its inputs?
                ❓ Does it modify anything outside its scope?
                ❓ Will it always give the same result for the same input?
                        If YES → Pure
                        If NO → Impure


------------------------------------------------------------------------------------------------------------------------------
Q. first class function ?

Book through hoil

----------------------------------------------------------------------------------------------------------------------------
Q. callback function ?


Book through hoil
----------------------------------------------------------------------------------------------------------------------------
Q. Higher order function ?

Book through hoil
----------------------------------------------------------------------------------------------------------------------------
🤔 map, reduce, filter ?

🅰️ Things to be learned :
     1. map method is used when we want transformation of whole array
     2. filter is used when we want to filter the array to obtain required value.
     3. reduce is used when we want to reduce the array to single value (eg: max, min, avg, sum, difference etc)
     4. reduce passes 2 arguments one function(which includes accumulator and current element of array) and another
          innitial value of accummulator

     📌 map
         eg:- 1     const arr = [5,1,3,2,6]

                    function double(x){
                        return x * 2
                    }

                    const output = arr.map(double)
                    console.log(output)            // [ 10, 2, 6, 4, 12 ]

        eg:- 2       const arr = [5,1,3,2,6]

                        function binary(x){
                            return x.toString(2)
                        }

                        const output = arr.map(binary)
                        console.log(output)             // [ '101', '1', '11', '10', '110' ]

        eg:- 3        const arr = [5,1,3,2,6]

                        const output = arr.map(function binary(x){
                            return x.toString(2)
                        })

                        console.log(output)           // [ '101', '1', '11', '10', '110' ]

        eg:- 4          const arr = [5,1,3,2,6]

                        const output = arr.map((x)=>{   via => variable, index, array
                            return x.toString(2)
                        })

                        console.log(output)               //  // [ '101', '1', '11', '10', '110' ]

    📌 filter
           eg:- 1
                        const arr = [5,1,3,2,6]

                        function isOdd(x){
                            return x % 2
                        }

                        const output = arr.filter(isOdd)
                        console.log(output)                   // [ 5, 1, 3 ]

           eg:- 2       const arr = [5,1,3,2,6]

                        function isEven(x){
                            return x % 2 === 0
                        }

                        const output = arr.filter(isEven)
                        console.log(output)                   // [ 2, 6 ]

           eg:- 3       const arr = [5,1,3,2,6]

                        function greaterThan4(x){
                            return x > 4
                        }

                        const output = arr.filter(greaterThan4)
                        console.log(output)                      // [ 5, 6 ]

           eg:- 4       const arr = [5,1,3,2,6]

                        const output = arr.filter((x)=>{
                            return    x < 3
                        })
                        console.log(output)                   // [ 1, 2 ]

    📌 reduce 
            eg:- 1      const arr = [5,1,3,2,6]

                        const output = arr.reduce(function(acc, curr){
                            acc = acc + curr
                            return  acc
                        }, 0)

                        console.log(output)              // 17

            eg:- 2      const arr = [5,1,3,2,6]

                        const output = arr.reduce(function(acc, curr){
                            if(curr > acc){
                                acc = curr
                            }
                            return  acc
                        }, 0)

                        console.log(output)                // 6

            eg:- 3      const users = [
                            {firstName: "akshay", lastName: "saini", age: 26},
                            {firstName: "donald", lastName: "trump", age: 75},
                            {firstName: "elon", lastName: "musk", age: 50},
                            {firstName: "deepika", lastName: "padukone", age: 26}
                            ]
                            
                                const output = users.map((x)=>{
                                return  x.firstName + " " + x.lastName
                                })

                                console.log(output)    // [ 'akshay saini', 'donald trump', 'elon musk', 'deepika padukone' ]


            eg:- 4       const users = [
                                {firstName: "akshay", lastName: "saini", age: 26},
                                {firstName: "donald", lastName: "trump", age: 75},
                                {firstName: "elon", lastName: "musk", age: 50},
                                {firstName: "deepika", lastName: "padukone", age: 26}
                                ]
                                
                            const output = users.reduce(function(acc, curr){
                                if(acc[curr.age]){
                                    acc[curr.age] = ++ acc[curr.age]
                                }else{
                                    acc[curr.age] = 1
                                }
                                return acc
                            }, {})

                            console.log(output)       // { '26': 2, '50': 1, '75': 1 }

            eg:- 5          const users = [
                                {firstName: "akshay", lastName: "saini", age: 26},
                                {firstName: "donald", lastName: "trump", age: 75},
                                {firstName: "elon", lastName: "musk", age: 50},
                                {firstName: "deepika", lastName: "padukone", age: 26}
                                ]
                                
                            const output = users.filter((x)=> x.age < 30).map((x)=> x.firstName)

                            console.log(output)       // [ 'akshay', 'deepika' ]
 

----------------------------------------------------------------------------------------------------------------------------
🤔  IIFE ?

🅰️   ✅ What is an IIFE?
        IIFE stands for Immediately Invoked Function Expression.
        It is a function that runs as soon as it is defined.
        It’s a design pattern used to create a private scope in JavaScript.

    ✅ How does it work?
          (function() {
            // code here
            })();

            (() => {
                // code here
                })();

            The outer parentheses () turn the function declaration into an expression.
            The second () immediately invokes the function.

     ✅ Why use an IIFE?
             Create private scope	Avoid polluting the global namespace
             Encapsulation	Encapsulate variables to avoid conflicts
             Module pattern (pre-ES6)	Used to simulate modules before ES6 introduced import/export
             Immediate execution	Useful for code that runs once (e.g., init setup)

    ✅ When should you use IIFE?
            When you want to execute code immediately during script load.
            When you need to protect variables from leaking into the global scope.
            In legacy JS (ES5 or earlier) where modules weren't available.
            When writing a self-contained utility block or one-time setup code.

    ⚠️ Edge Cases / Corner Cases with IIFE
            1. Forgetting to wrap in parentheses
                function() {
                    // invalid syntax ❌    Fix: Wrap in () to make it a function expression.
                    }();  

            2. Arrow function IIFE and this context
                (() => {
                    console.log(this); // `this` is lexical, not dynamic
                    })();

                In arrow functions, this is not bound to the function — it takes this from the surrounding scope.

            3. IIFE return value capturing
                const result = (function(x, y) {
                    return x + y;
                    })(2, 3);

                    console.log(result); // 5 
                You can store the result of an IIFE in a variable.

----------------------------------------------------------------------------------------------------------------------------
🤔 Currying function ?

🅰️  ✅What is Function Currying?
        Definition: Currying is a functional programming technique where a function with multiple arguments 
        is transformed into a sequence of functions each taking a single argument.

        Instead of calling f(a, b, c), you call f(a)(b)(c).

    ✅How does Currying work in JavaScript?
        In JavaScript, currying can be implemented using closures.

        It returns nested functions, each capturing the argument and returning another function until all arguments are provided.

        eg 1:- // Normal function
                    function add(a, b, c) {
                    return a + b + c;
                    }

                    // Curried version
                    function curriedAdd(a) {
                    return function(b) {
                        return function(c) {
                        return a + b + c;
                        };
                    };
                    }

                    // Usage
                    curriedAdd(1)(2)(3); // 6

        eg 2:- let multiply = function(x){
                    return function (y){
                        return function(z){
                            console.log(x + y + z)         // 9
                        }
                    }
                }

                multiply(2)(3)(4);

        eg 3:-  let multiply = function(x){
                        return function (y){
                            return function(z){
                                console.log(x + y + z)     // 9
                            }
                        }
                    }

                    let res1 = multiply(2)
                    let res2 = res1(3)
                    res2(4)

    ✅ Why use Function Currying?
            Reusability: Create specialized versions of functions.
            Function composition: Makes code more readable and composable.
            Partial application: You can pass some arguments now and the rest later.
            Helps with functional programming patterns.

    ✅ When to use Currying?
            When dealing with functional pipelines, like in React, Redux, or Ramda.js.
            Useful in event handlers, form validations, or middleware patterns where parameters are passed in stages.

----------------------------------------------------------------------------------------------------------------------------
Q. callback hell ?

----------------------------------------------------------------------------------------------------------------------------
Q. Promises, promises stage/state ?

----------------------------------------------------------------------------------------------------------------------------
Q. promise chain ?

----------------------------------------------------------------------------------------------------------------------------
🤔 Promise API ?

🅰️      let myPromise = new Promise((resolve, reject)=>{

        let success =  true;

        console.log("before promise")
        setTimeout(()=>{
            if(success){
                resolve("operation succesfully")
                console.log("In promise")
            }else{
                reject("operation failed")
            }
        }, 5000)

        console.log("After promise")
        })

        myPromise.then((result) => console.log(result))      // operation succesfully
        .catch((error)=> console.log(error))                 // operation failed

        // PROGRAM FLOW :-

        // before promise
        // After promise
        // operation successfull

        // Async/Await is Better for simplicity and Readablility: If you are working with asynchronous code that involves sequential operation,
         async/await id generally the preferred approach because it makes the code look like its synchronous (which is easier to follow and debug)

        // Promise are useful for parallelism and complex flows: If you're dealing with multiple asynchronous operation that don't depend on each other
         (or need to run in parallel), Promises and methods like Promise.all() or Promise.race() are label.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
🤔 async await ?

🅰️  let myPromise = new Promise((resolve, reject) => {

        let success = true;

        setTimeout(() => {
          if (success) {
            resolve("operation successfull");
          } else {
            reject("operation failed");
          }
        }, 5000);
      });

      myPromise
        .then((result) => console.log(result)) // "operation successfull"
        .catch((error) => console.log(error)); // operation failed

      async function asyncFunction() {
        try {
          console.log("Before async await");

          let result = await myPromise; //  waits for the promise to resolve or reject
          console.log("After1 async await");
          console.log(result); // operation successfull
          console.log("After2 async await");
        } catch (error) {
          console.log(error); // operation failed
        }
      }

      asyncFunction();

      // PROGRAM FLOW:
      
      // before async await
      // operation successfull
      // After1 async await
      // operation successfull
      // After2 async await

      // Async/Await is Better for simplicity and Readablility: If you are working with asynchronous code that involves sequential operation,
       async/await id generally the preferred approach because it makes the code look like its synchronous (which is easier to follow and debug)

      // Promise are useful for parallelism and complex flows: If you're dealing with multiple asynchronous operation that don't 
      depend on each other (or need to run in parallel), Promises and methods like Promise.all() or Promise.race() are label.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î Execution context & call stack ?
üÖ∞Ô∏è  üìå Why (Why do we need Execution Context & Call Stack?)
        JavaScript is a single-threaded language, meaning it executes one operation at a time.
         To efficiently manage function execution and keep track of which function is currently running, 
         JavaScript uses Execution Context and Call Stack.
        Without them, JavaScript wouldn't know which function to execute next or how to maintain function scopes.

    üìå How (How does Execution Context & Call Stack work?)
            Execution Context
            When JavaScript executes a script, it creates an Execution Context to manage the execution of code.

            Each Execution Context has two phases:
            1Ô∏è‚É£ Creation Phase

                Creates the Variable Environment (stores variables & functions).
                Sets up the Lexical Environment (scopes & references).
                Sets this keyword based on the context.

            2Ô∏è‚É£ Execution Phase

                Assigns values to variables.
                Executes function calls & statements.

            Call Stack
            The Call Stack is a stack data structure that follows LIFO (Last In, First Out) to manage function execution.

            When a function is called, its Execution Context is pushed onto the Call Stack.
            When the function completes, it is popped off the stack.
            If a function calls another function, the new function‚Äôs Execution Context is pushed on top.

            Example : function first() {
                            console.log("First Function");
                            second();
                        }
                        function second() {
                            console.log("Second Function");
                            third();
                        }
                        function third() {
                            console.log("Third Function");
                        }
                        first();

            Call Stack Flow:

                first() is called ‚Üí first Execution Context is pushed.
                Inside first(), second() is called ‚Üí second Execution Context is pushed.
                Inside second(), third() is called ‚Üí third Execution Context is pushed.
                third() completes ‚Üí Removed from the stack.
                second() completes ‚Üí Removed from the stack.
                first() completes ‚Üí Removed from the stack.
                The stack is now empty.

    üìå What of execution context & call stack ?
    
    The Execution Context manages function execution (GEC, FEC).
    The Call Stack maintains the order of function calls.

    ‚ö†Ô∏è Edge Cases / Corner Cases

        Stack Overflow (Infinite Recursion)
        Asynchronous Functions & Call Stack : JavaScript uses the Event Loop & Callback Queue for asynchronous operations.
        Lexical Scope & Closures : Nested functions can retain access to outer function variables.
----------------------------------------------------------------------------------------------------------------------------
Q. Hoisting var, let, const, temporal dead zone ?
 
 Book through hoil

----------------------------------------------------------------------------------------------------------------------------
Q. Window & this keyword ?

Book through hoil
----------------------------------------------------------------------------------------------------------------------------
ü§î undefined vs not defined vs null ?
üÖ∞Ô∏è   üìå why ?
        JavaScript has multiple ways to represent missing or uninitialized values,
        and understanding the differences between them helps in debugging and avoiding runtime errors. 
        Using the wrong type can lead to unexpected behaviors.

    üìå how ?
        ‚úÖundefined
        A variable is declared but not assigned a value.
        Functions without a return statement return undefined by default.
        Accessing an object property that doesn‚Äôt exist returns undefined.

        ‚úÖnot defined
        A variable is not declared at all.
        Accessing a variable that has never been declared will throw a ReferenceError.

        ‚úÖnull
        null is an explicit assignment to indicate "no value".
        It must be manually assigned to a variable.
        Often used to reset a variable or indicate missing values in databases.

        üî• Edge Cases / Corner Cases

            console.log(typeof undefined); // "undefined"
            console.log(typeof null); // "object" (historical JS bug)
            console.log(typeof x); // "undefined" (if declared but uninitialized)
            console.log(typeof notDeclaredVariable); // "undefined" (no ReferenceError)

            The reason typeof notDeclaredVariable returns "undefined" instead of throwing a ReferenceError is due to ECMAScript specification design.
            This behavior was intentionally introduced to make JavaScript more fault-tolerant.

            Early versions of JavaScript needed fault tolerance

            In early JavaScript implementations, encountering an undeclared variable would have caused a crash.
            Allowing typeof to return "undefined" instead of throwing an error prevented unnecessary runtime failures.

            console.log(typeof undeclaredVar); // ‚úÖ "undefined"
            console.log(undeclaredVar); // ‚ùå ReferenceError: undeclaredVar is not defined



            console.log(null == undefined); // true (loose equality)
            Because JavaScript considers them both "empty" values and treats them as equal in loose comparisons.
            console.log(null === undefined); // false (strict equality)
            console.log(null == false); // false
            console.log(undefined == false); // false
            console.log(null == 0); // false
            console.log(undefined == 0); // false

            JSON.stringify({ a: null, b: undefined });    // '{"a":null}' (undefined is removed!)
           

----------------------------------------------------------------------------------------------------------------------------
Q. scope, scope chain, lexical env ?

Book through hoil

----------------------------------------------------------------------------------------------------------------------------
Q. function scope, block scope, global scope ?

----------------------------------------------------------------------------------------------------------------------------
ü§î Difference  between closure and scope ?
üÖ∞Ô∏è  ‚úÖ Scope:
        Scope determines where variables are accessible in your code. It defines the lifetime and visibility of a variable.
        Global Scope ‚Üí Variables declared outside any function are accessible everywhere.
        Function Scope ‚Üí Variables declared inside a function are only accessible within that function.
        Block Scope (Introduced with let & const) ‚Üí Variables inside {} blocks are limited to that block.

    ‚úÖ Closure:
        A closure is a function that remembers the variables from its parent scope, even after the parent function has executed.
        Closures help in data encapsulation and creating private variables.
        It allows functions to maintain state between executions.

    üî• Edge Cases / Corner Cases
         üîπ   Edge Case 1: Closure Retaining Stale Data, Issue: Each instance of createCounter() has its own closure.

                    function createCounter() {
                    let count = 0;
                    return function () {
                        count++;
                        return count;
                    };
                    }

                const counter1 = createCounter();
                const counter2 = createCounter();

                console.log(counter1()); // 1 (same closure share state)
                console.log(counter1()); // 2

                console.log(counter2()); // 1 (Separate closure, doesn't share state)

          üîπ Edge Case 2: Loop with var in Closures

                    for (var i = 0; i < 3; i++) {
                        setTimeout(() => console.log(i), 1000);
                    }

                    3
                    3
                    3
         
                    Because var is function-scoped, so the final value of i (which is 3) is used for all closures.


          
----------------------------------------------------------------------------------------------------------------------------
Q. closures, closures with setTimeout, setInterval, Tust Issues with setTimeout ?

Book through hoil

----------------------------------------------------------------------------------------------------------------------------
Q. Normal function vs arrow function ?

----------------------------------------------------------------------------------------------------------------------------
ü§î. types of function ?
üÖ∞Ô∏è Void function: functions which does not return anything, they just display value.

----------------------------------------------------------------------------------------------------------------------------
Q. How many ways you can pass arguments to the functions ?

-----------------------------------------------------------------------------------------------------------------------------
Q. How to use default parameters in function ?

------------------------------------------------------------------------------------------------------------------------------
Q. pure vs Impure function ?

------------------------------------------------------------------------------------------------------------------------------
Q. first class function ?

Book through hoil

----------------------------------------------------------------------------------------------------------------------------
Q. callback function ?


Book through hoil
----------------------------------------------------------------------------------------------------------------------------
Q. Higher order function ?

Book through hoil
----------------------------------------------------------------------------------------------------------------------------
Q. map, reduce, filter ?

Book through hoil
----------------------------------------------------------------------------------------------------------------------------
Q. IIFE ?

----------------------------------------------------------------------------------------------------------------------------
Q. Currying function ?

----------------------------------------------------------------------------------------------------------------------------
Q. callback hell ?

----------------------------------------------------------------------------------------------------------------------------
Q. Promises, promises stage/state ?

----------------------------------------------------------------------------------------------------------------------------
Q. promise chain ?

----------------------------------------------------------------------------------------------------------------------------
ü§î Promise API ?

üÖ∞Ô∏è      let myPromise = new Promise((resolve, reject)=>{

        let success =  true;

        console.log("before promise")
        setTimeout(()=>{
            if(success){
                resolve("operation succesfully")
                console.log("In promise")
            }else{
                reject("operation failed")
            }
        }, 5000)

        console.log("After promise")
        })

        myPromise.then((result) => console.log(result))      // operation succesfully
        .catch((error)=> console.log(error))                 // operation failed

        // PROGRAM FLOW :-

        // before promise
        // After promise
        // operation successfull

        // Async/Await is Better for simplicity and Readablility: If you are working with asynchronous code that involves sequential operation,
         async/await id generally the preferred approach because it makes the code look like its synchronous (which is easier to follow and debug)

        // Promise are useful for parallelism and complex flows: If you're dealing with multiple asynchronous operation that don't depend on each other
         (or need to run in parallel), Promises and methods like Promise.all() or Promise.race() are label.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î async await ?

üÖ∞Ô∏è  let myPromise = new Promise((resolve, reject) => {

        let success = true;

        setTimeout(() => {
          if (success) {
            resolve("operation successfull");
          } else {
            reject("operation failed");
          }
        }, 5000);
      });

      myPromise
        .then((result) => console.log(result)) // "operation successfull"
        .catch((error) => console.log(error)); // operation failed

      async function asyncFunction() {
        try {
          console.log("Before async await");

          let result = await myPromise; //  waits for the promise to resolve or reject
          console.log("After1 async await");
          console.log(result); // operation successfull
          console.log("After2 async await");
        } catch (error) {
          console.log(error); // operation failed
        }
      }

      asyncFunction();

      // PROGRAM FLOW:
      
      // before async await
      // operation successfull
      // After1 async await
      // operation successfull
      // After2 async await

      // Async/Await is Better for simplicity and Readablility: If you are working with asynchronous code that involves sequential operation,
       async/await id generally the preferred approach because it makes the code look like its synchronous (which is easier to follow and debug)

      // Promise are useful for parallelism and complex flows: If you're dealing with multiple asynchronous operation that don't 
      depend on each other (or need to run in parallel), Promises and methods like Promise.all() or Promise.race() are label.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î Execution context & call stack ?
üÖ∞Ô∏è  üìå Why (Why do we need Execution Context & Call Stack?)
        JavaScript is a single-threaded language, meaning it executes one operation at a time.
         To efficiently manage function execution and keep track of which function is currently running, 
         JavaScript uses Execution Context and Call Stack.
        Without them, JavaScript wouldn't know which function to execute next or how to maintain function scopes.

    üìå How (How does Execution Context & Call Stack work?)
            Execution Context
            When JavaScript executes a script, it creates an Execution Context to manage the execution of code.

            Each Execution Context has two phases:
            1Ô∏è‚É£ Creation Phase

                Creates the Variable Environment (stores variables & functions).
                Sets up the Lexical Environment (scopes & references).
                Sets this keyword based on the context.

            2Ô∏è‚É£ Execution Phase

                Assigns values to variables.
                Executes function calls & statements.

            Call Stack
            The Call Stack is a stack data structure that follows LIFO (Last In, First Out) to manage function execution.

            When a function is called, its Execution Context is pushed onto the Call Stack.
            When the function completes, it is popped off the stack.
            If a function calls another function, the new function‚Äôs Execution Context is pushed on top.

            Example : function first() {
                            console.log("First Function");
                            second();
                        }
                        function second() {
                            console.log("Second Function");
                            third();
                        }
                        function third() {
                            console.log("Third Function");
                        }
                        first();

            Call Stack Flow:

                first() is called ‚Üí first Execution Context is pushed.
                Inside first(), second() is called ‚Üí second Execution Context is pushed.
                Inside second(), third() is called ‚Üí third Execution Context is pushed.
                third() completes ‚Üí Removed from the stack.
                second() completes ‚Üí Removed from the stack.
                first() completes ‚Üí Removed from the stack.
                The stack is now empty.

    üìå What of execution context & call stack ?
    
    The Execution Context manages function execution (GEC, FEC).
    The Call Stack maintains the order of function calls.

    ‚ö†Ô∏è Edge Cases / Corner Cases

        Stack Overflow (Infinite Recursion)
        Asynchronous Functions & Call Stack : JavaScript uses the Event Loop & Callback Queue for asynchronous operations.
        Lexical Scope & Closures : Nested functions can retain access to outer function variables.
----------------------------------------------------------------------------------------------------------------------------
ü§î Hoisting var, let, const, temporal dead zone ?
 
üÖ∞Ô∏è Hoisting:- By which you can access variable & functions even before you have initialized it or you have put some value in it,
                you can access it without any error.

                ‚úÖ code snippet 1
                      var x = 7

                        function getName(){
                            console.log("Namaste Javascript")
                        }

                        getName()
                        console.log(x)    

                        output :
                        Namaste Javascript
                        7

                ‚úÖ code snippet 2

                        getName()
                        console.log(x)

                        var x = 7

                        function getName(){
                            console.log("Namaste Javascript")
                        }

                          output :
                          Namaste Javascript
                          undefined

                ‚úÖ code snippet 3

                          getName()
                          console.log(x)

                          function getName(){
                              console.log("Namaste Javascript")
                          }

                          output :
                          Namaste Javascript
                          ReferenceError: x is not defined

                ‚úÖ code snippet 4

                          var x = 7

                            function getName(){
                                console.log("Namaste Javascript")
                            }

                            console.log(getName)

                            or 

                              console.log(getName)

                              var x = 7

                              function getName(){
                                  console.log("Namaste Javascript")
                              }


                            output :
                            ∆í getName(){
                                  console.log("Namaste Javascript")
                              }



                ‚úÖ code snippet 5

                              getName()
                              console.log(x)
                              console.log(getName)

                              var x = 7

                              function getName(){
                                  console.log("Namaste Javascript")
                              }

                               output :
                               Namaste Javascript
                                undefined
                                ∆í getName(){
                                  console.log("Namaste Javascript")
                              }


                ‚úÖ code snippet 6

                                  getName()
                                  console.log(x)
                                  console.log(getName)

                                  var x = 7

                                  var getName = ()=> {   
                                      console.log("Namaste Javascript")
                                  }

                                   output :
                                   TypeError: getName is not a function
                                   Reason = In this getName is arrow function, so here it behaves like a variable,
                                            so in memory creation getName = undefined 

                ‚úÖ code snippet 7

                                  getName()
                                  console.log(x)
                                  console.log(getName)

                                  var x = 7

                                  var getName = function() {   
                                      console.log("Namaste Javascript")
                                  }

                                  output :
                                   TypeError: getName is not a function
                                   Reason = In this getName is arrow function, so here it behaves like a variable,
                                            so in memory creation getName = undefined 

                ‚úÖ code snippet 8

                                    getName()
                                    console.log(x)
                                    console.log(getName)

                                    var x = 7

                                    function getName() {
                                        console.log("Namaste Javascript")
                                    }

                                    output :
                                    Namaste Javascript
                                    undefined
                                    ∆í getName(){
                                        console.log("Namaste Javascript")
                                    }

                ‚úÖ code snippet 9
                                  
                                  var name = "vinod"
                                  console.log(name)      // vinod

                                  let name = "bahadur"
                                  console.log(name)      // bahadur

                                  const name = "thapa"
                                  console.log(name)      // thapa

                ‚úÖ code snippet 10
                                  
                                  var name = "vinod"
                                  var name = "thapa"
                                  console.log(name)      // thapa

                                  let name = "vinod"
                                  let name = "thapa"
                                  console.log(name)      // SyntaxError: Identifier 'name' has already been declared
                                  // you can declare the same variable using "let" more than once in the same scope

                                   let name = "vinod"
                                  name = "thapa"
                                  console.log(name)       // thapa

                                  const name = "vinod"
                                  const name = "thapa"
                                  console.log(name)       // SyntaxError: Identifier 'name' has already been declared

                                  const name = "vinod"
                                   name = "thapa"
                                  console.log(name)       // TypeError: Assignment to constant variable.

                ‚úÖ code snippet 11

                                  function modJS(love){
                                    if(love){
                                        let name = "vinod"
                                        const sname = "thapa"
                                        console.log(name + sname)     // vinodthapa
                                    }                                  
                                  }
                                  
                                  modJS(true)


                                  function modJS(love){
                                    if(love){
                                        var name = "vinod"
                                        var sname = "thapa"
                                        console.log(name + sname)     // vinodthapa
                                    }                                  
                                  }
                                  
                                  modJS(true)


                                  function modJS(love){
                                    if(love){
                                        var name = "vinod"
                                        var sname = "thapa"                                        
                                    }      
                                    console.log(name + sname)     // vinodthapa                            
                                  }
                                  
                                  modJS(true)


                                  function modJS(love){
                                    if(love){
                                        let name = "vinod"
                                        const sname = "thapa"                                        
                                    }      
                                    console.log(name + sname)     // ReferenceError: name is not defined                           
                                  }
                                  
                                  modJS(true)

                ‚úÖ code snippet 12

                                  var whoWins = "India"

                                    if(true){
                                        var whoWins = "NZ"
                                        console.log(whoWins)       // NZ
                                    }
                                    console.log(whoWins)            // NZ


                                  let whoWins = "India"

                                    if(true){
                                        let whoWins = "NZ"
                                        console.log(whoWins)       // NZ
                                    }
                                    console.log(whoWins)            // India


                                  const whoWins = "India"

                                    if(true){
                                        const whoWins = "NZ"
                                        console.log(whoWins)       // NZ
                                    }
                                    console.log(whoWins)            // India

                  ‚úÖ code snippet 13

                                    console.log(b)        // undefined
                                      let a = 100
                                      var b = 100

                                    console.log(a)        // ReferenceError: Cannot access 'a' before initialization
                                      let a = 100
                                      var b = 100
                                    
                                      let a = 100
                                      console.log(a)        // 100
                                      var b = 100

  Temporal Dead Zone = is the time since when this, let a / const xyz was hoisted & till it is initialised same value.
                          time btn both of this id known as "temporal dead zone"

                          whenever you access a variable in temporal dead zone it throws "Reference error"

                          both, let a & var b memory was allocated but var b was attached to global object,
                          let a & const xyz they are also allocated memory & that is what is called Hoisting,
                          but, they are stored in diff memory space & you cannot access this memory space before you
                          have put any value in them/ Initialised/ decalred. 
                                
                 ‚úÖ code snippet 14

                                    console.log(x)      // ReferenceError: x is not defined
                                    let a = 100
                                    var b = 100

                                    let a = 10
                                    let a = 100
                                    console.log(a)      // SyntaxError: Identifier 'a' has already been declared

                                    let a = 10
                                    let a = 100
                                    console.log(a)      // SyntaxError: Identifier 'a' has already been declared
                                    
                                    let a = 10
                                     a = 100
                                    console.log(a)      // 100

                                   let a = 10
                                    var b =  100
                                    var b = 1000
                                    console.log(b)     // 1000

                                    let a                    -> declare
                                    const b =  100
                                    a = 1000                  -> Initialize
                                    console.log(a)      // 1000

                                    const b;
                                    b = 1000
                                    console.log(b)     // SyntaxError: Missing initializer in const declaration

                                    const b = 10
                                    b = 1000
                                    console.log(b)    // TypeError: Assignment to constant variable.

                                    const b = 1000
                                    console.log(b)     // 1000

                  ‚úÖ code snippet 15
                                    {
                                      var a = 10;  // a hoisted in global space
                                      let b = 20;  // b & c are hoisted in different memory space
                                      const c =30
                                      
                                      console.log(a)      // 10
                                      console.log(b)      // 20
                                      console.log(c)      // 30
                                  }

                                  console.log(a)      // 10
                                  console.log(b)      ReferenceError: b is not defined
                                  console.log(c)  

                  ‚úÖ code snippet 16  (shadowing in JS)

                                    var a = 100; (both var a, are pointing to same global scope)
                                      {
                                          var a = 10;
                                          let b = 20;
                                          const c = 30;
                                          console.log(a)      // 10
                                      }
                                      console.log(a)          // 10

                                      let b = 100;     // here b has a script scope
                                          {
                                              var a = 10;    //  here a has global scope
                                              let b = 20;    // here b has block scope
                                              const c = 30;  // here c has block scope
                                              console.log(b)    // 20
                                          }
                                          console.log(b)      // 100

                                      const c = 100;
                                            {
                                                var a = 10;
                                                let b = 20;
                                                const c = 30;
                                                console.log(c)    // 30
                                            }
                                            console.log(c)        // 100


                                        const c = 100;
                                            function x(){
                                                const c = 30
                                                console.log(c)    // 30
                                            }

                                            x()
                                            console.log(c)          // 100

                    ‚úÖ code snippet 16  (illegal shadowing in JS)

                                        var a = 20
                                        {
                                          var a = 20   ‚úÖ
                                        }


                                        let a = 20
                                        {
                                          var a = 20   ‚ùå  // syntax error : Identifier a is already been declared.
                                          var crossing this block scope interfying with let, var is always attached to 
                                          global scope, no matter where it is declare & also var is a function scope.
                                        }

                                        let a = 20
                                        function x(){
                                          var a = 20          ‚úÖ
                                        }

                                        let a = 20;
                                        {
                                          let a = 20;         ‚úÖ
                                        }


                                        var a = 20;
                                        {
                                          let a = 20;         ‚úÖ
                                        }

                      ‚úÖ code snippet 17

                                        const a = 20
                                            {
                                                const a = 100
                                                {
                                                    const a = 200
                                                    console.log(a)    // 200
                                                }
                                            }
                                      

                                      const a = 20
                                            {
                                                const a = 100
                                                {
                                                    const a = 200
                                                    
                                                }
                                                console.log(a)          // 100
                                            }


                                      const a = 20
                                            {
                                                const a = 100
                                                {
                                                    console.log(a)          // 100    
                                                }         
                                            }

                                       const a = 20
                                            {
                                                const a = 100
                                                {
                                                    const a = 200
                                                }
                                            }
                                                console.log(a)         // 20

----------------------------------------------------------------------------------------------------------------------------
ü§î Window & this keyword ?

üÖ∞Ô∏è  üìå <script>  üëÄ
            // If you are running JS in browsers, the global object is "window",
            // In nodejs env, the global object is "global" or "globalThis"

            console.log(this) //window -> Alone, this refers to the global object, 

            function sum(){
                var add = 2 + 2
                console.log(add)  // 4
                console.log(this)  // window -> In a method, this refers to the global object.
            }

                sum()
        </script>

    üìå <script> üëÄ
            const thapa = {
                name: "vinod thapa",
                qualif: "MCS",
                sum: function () {
                var add = 2 + 2;
                console.log(add);    // 4
                console.log(this);   //  {name: 'vinod thapa', qualif: 'MCS', sum: ∆í}
                // In a method, this refers to the owner object
                
                console.log(this.name);   // vinod thapa
                },
            };

            thapa.sum()
         </script>

    üìå <script>  üëÄ
      "use strict";

            function sum() {
                var add = 2 + 2;
                console.log(add); // 4
                console.log(this); //  undefined
                // In a function, in "strict mode", this is undefined
            }

            sum();
        </script>

    üìå <script> üëÄ
          "use strict";

                function x() {
                    console.log(this)    // undefined
                }
                
                x()
        </script>

    üìå <script> üëÄ
            function x() {
                console.log(this)    // window
            }

      // If the value of this keyword is undefined or null, this keyword will be replaced with "global object"
      //  here, In browser it is "window".
       
      x()
        </script>


    üìå <script>  üëÄ
         "use strict";

            function x(){
                console.log(this)  // undefined
            }

            x()
            window.x()  // window

        "use strict" -> advantage -> Debugging error is Simple

        strict mode characteristics :
        1. Duplicate arguments are not allowed by Developers.
        2. Developers are not allowed to create global variables.

        </script>


    üìå <script> üëÄ

        const student = {
            name: "Akshay",
            printName : function(){
                console.log(this.name)   // Akshay
            }
        }

        student.printName()

        const student2 = {
            name : "prashant"
        }

        student2.printName()    // Uncaught TypeError: student2.printName is not a function

        </script>


    üìå <script>  üëÄ

        const student = {
            name: "Akshay",
            printName : function(){
                console.log(this.name)
            }
        }

        student.printName()   // Akshay

        const student2 = {
            name : "prashant"
        }

        student.printName.call(student2)   // prashant
        // call, apply, bind, are important functions used to manupilate the value of "this", or overwrite
            the value of "this", when calling methods & sharing them between objects.

        </script>

    üìå <script> üëÄ
      // this inside arrow function
      // Arrow function do not have their own "this" binding and take the value of the enclosing lexical context,
      //  often the global space

            "use strict" or do not use "use strict", answer is same

            const obj = {
                a: 10,
                x: () => {
                console.log(this); // window
                },
            };

            obj.x();
    </script>

    üìå  <script> üëÄ
          // this inside nested arrow function.
                "use strict" or do not use "use strict", answer is same

            const obj = {
                a: 10,
                x: function() {
                const y = () =>{
                    console.log(this)   // {a: 10, x: ∆í}
                }
                y()
                },
            };

            obj.x();
    </script>

    üìå      <script> üëÄ

                function x(){
                const y = () =>{
                        console.log(this)    // window object

                    }
                    y()
                }

                x()
    </script>


    üìå <script> üëÄ
                "use strict" 

                function x(){
                const y = () =>{
                        console.log(this)    // undefined
                    }
                    y()
                }

                x()
      </script>

    üìå<script> üëÄ
                "use strict";

                function x(){
                const y = () =>{
                        console.log(this)    // window object
                    }
                    y()
                }

                window.x()
       </script>  

    
----------------------------------------------------------------------------------------------------------------------------
ü§î undefined vs not defined vs null ?
üÖ∞Ô∏è   üìå why ?
        JavaScript has multiple ways to represent missing or uninitialized values,
        and understanding the differences between them helps in debugging and avoiding runtime errors. 
        Using the wrong type can lead to unexpected behaviors.

    üìå how ?
        ‚úÖundefined
        A variable is declared but not assigned a value.
        Functions without a return statement return undefined by default.
        Accessing an object property that doesn‚Äôt exist returns undefined.

        ‚úÖnot defined
        A variable is not declared at all.
        Accessing a variable that has never been declared will throw a ReferenceError.

        ‚úÖnull
        null is an explicit assignment to indicate "no value".
        It must be manually assigned to a variable.
        Often used to reset a variable or indicate missing values in databases.

        üî• Edge Cases / Corner Cases

            console.log(typeof undefined); // "undefined"
            console.log(typeof null); // "object" (historical JS bug)
            console.log(typeof x); // "undefined" (if declared but uninitialized)
            console.log(typeof notDeclaredVariable); // "undefined" (no ReferenceError)

            The reason typeof notDeclaredVariable returns "undefined" instead of throwing a ReferenceError is due to ECMAScript specification design.
            This behavior was intentionally introduced to make JavaScript more fault-tolerant.

            Early versions of JavaScript needed fault tolerance

            In early JavaScript implementations, encountering an undeclared variable would have caused a crash.
            Allowing typeof to return "undefined" instead of throwing an error prevented unnecessary runtime failures.

            console.log(typeof undeclaredVar); // ‚úÖ "undefined"
            console.log(undeclaredVar); // ‚ùå ReferenceError: undeclaredVar is not defined



            console.log(null == undefined); // true (loose equality)
            Because JavaScript considers them both "empty" values and treats them as equal in loose comparisons.
            console.log(null === undefined); // false (strict equality)
            console.log(null == false); // false
            console.log(undefined == false); // false
            console.log(null == 0); // false
            console.log(undefined == 0); // false

            JSON.stringify({ a: null, b: undefined });    // '{"a":null}' (undefined is removed!)
           

----------------------------------------------------------------------------------------------------------------------------
ü§î scope, scope chain, lexical env ?

üÖ∞Ô∏è  Scope : means you can access a specific variable or function in our code.
     Scope chain : chain of lexcial env & parent references
     lexcial env : local memory + reference to the lexical Environment

     pak <- Ind  (Inside out value searching, OK)‚úÖ
     pak -> Ind  (Outside In value searching, Not OK)‚ùå

     ‚úÖ code snippet 1

                  function a(){
                        console.log(b)     // 10
                    }

                    var b = 10
                    a()

      ‚úÖ code snippet 2

                    var b = 10
                      function a(){
                          var x = 100
                          
                      }
                      console.log(b)      // 10
                      console.log(x)      // ReferenceError: x is not defined
                      a()

       ‚úÖ code snippet 3

                          function a(){
                              c()
                              function c(){
                                  console.log(b)   // 10
                              }
                              
                          }
                          var b = 10
                          a()

       ‚úÖ code snippet 4

                          function a(){
                            var b = 10
                              c()
                              function c(){
                                  console.log(b)   // 10
                              }
                              
                          }
                          
                          a()
          
       ‚úÖ code snippet 5

                          function a(){
                            var b = 10
                              c()
                              function c(){
                                  
                              }
                              
                          }
                          
                          a()
                          console.log(b)   // ReferenceError: b is not defined
          
----------------------------------------------------------------------------------------------------------------------------
ü§î function scope, block scope, global scope ?

üÖ∞Ô∏è  var is function scoped
    let & const is block scoped

    In JavaScript, variables have three types of scope: Global Scope, Function Scope, and Block Scope. 
    Global variables can be accessed anywhere, Function Scope means a variable is accessible only inside a function, 
    and Block Scope applies to variables declared inside {} using let or const.

    Edge Case: If a global variable is declared using var, it will be added to the window object in browsers.
    Edge Case: If a variable is declared with var inside a function, it will still have function scope but will 
                not be block-scoped inside loops or conditionals.
    

      var inside a block still has function scope, not block scope
          function test() {
          if (true) {
              var x = 10;
          }
          console.log(x); // ‚úÖ Works! (Function Scoped)
          }
          test();


      let and const respect block scope
            function test() {
            if (true) {
                let y = 20;
            }
            console.log(y); // ‚ùå ReferenceError: y is not defined
        }
        test();
----------------------------------------------------------------------------------------------------------------------------
ü§î Difference  between closure and scope ?
üÖ∞Ô∏è  ‚úÖ Scope:
        Scope determines where variables are accessible in your code. It defines the lifetime and visibility of a variable.
        Global Scope ‚Üí Variables declared outside any function are accessible everywhere.
        Function Scope ‚Üí Variables declared inside a function are only accessible within that function.
        Block Scope (Introduced with let & const) ‚Üí Variables inside {} blocks are limited to that block.

    ‚úÖ Closure:
        A closure is a function that remembers the variables from its parent scope, even after the parent function has executed.
        Closures help in data encapsulation and creating private variables.
        It allows functions to maintain state between executions.

    üî• Edge Cases / Corner Cases
         üîπ   Edge Case 1: Closure Retaining Stale Data, Issue: Each instance of createCounter() has its own closure.

                    function createCounter() {
                    let count = 0;
                    return function () {
                        count++;
                        return count;
                    };
                    }

                const counter1 = createCounter();
                const counter2 = createCounter();

                console.log(counter1()); // 1 (same closure share state)
                console.log(counter1()); // 2

                console.log(counter2()); // 1 (Separate closure, doesn't share state)

          üîπ Edge Case 2: Loop with var in Closures

                    for (var i = 0; i < 3; i++) {
                        setTimeout(() => console.log(i), 1000);
                    }

                    3
                    3
                    3
         
                    Because var is function-scoped, so the final value of i (which is 3) is used for all closures.


          
----------------------------------------------------------------------------------------------------------------------------
ü§î closures, closures with setTimeout, setInterval, Tust Issues with setTimeout ?

üÖ∞Ô∏è  closures in js only work with functions
    closures ie Inner function can have access to the outer function variable as well as global variables.
    imp: It access to reference of variable & not to memory variable value.
    1.     <script>
                function x(){
                    var a = 7
                    function y(){
                        console.log(a)     // 7
                    }
                    y()
                }

                x()
            </script>

    2.      Assigning a function to the variable

            <script>
                    function x(){
                        var a = function y(){
                            console.log(a)     
                        }  
                        y()
                    }

                    x()
            </script> 

    3.      on function call you can pass a another function as a argument/parameter

            <script>
                function x(){
                    var a = 7
                    
                    y()
                }

                x( function y(){
                        console.log(a)     
                    })
            </script>

    4.      Similarly you can even return this functions from function

            <script>
                function x(){
                    var a = 7
                        function y(){
                            console.log(a)     // 7
                        }
                        return y 
                    }

                    var z = x()
                    console.log(z)   // ∆í y(){
                                        //   console.log(a)     
                                        // }
                    z()
            </script>

            x() ch kaam zhala ahe, so yach execution context, call stack madhun vanish zhala ahe & callstack is empty but z madhe fun  y(){......} ahe,
            ani te ata function scope cha baher ahe, means te ata global scope madhe ahe but tevha z() la call karto tevha tyachi value 7 yete but 
            commonly bagyala gela tar z() global madhe allymule tyachi value "undefined" or "null" alli phaije
            but
            when function are returned from another function they still maintain there lexical scope (they remember where they were actually present) & Also
            remember parameter & varaible value. 

            uses of closures - module design pattern, function currying, memoize, HOF, maintaining state in async world, setTimeouts & iterators ......

        5.      cool developers do this but not cool now onwards

            <script>
                function x(){
                    var a = 7
                      return function y(){
                            console.log(a)     // 7
                        } 
                    }

                    var z = x()
                    console.log(z)   // ∆í y(){
                                        //   console.log(a)     
                                        // }
                                        
                    z()           // 7
            </script>

        6.    <script>
                function x(){
                    var a = 7
                       function y(){
                            console.log(a)     // 100
                        } 
                    a = 100;
                    return y
                    }

                    var z = x()
                    console.log(z)           
                    z()                       // 100
            </script>

        7.    <script>
                   
                    function z() {
                        var b = 900;
                         function x() {
                            var a = 7;
                            function y() {
                                console.log(a, b);      // 7, 900
                            }
                         y();
                        }
                      x();
                    }

                    z();
      
         // calling inner function is imp, If you don't code won't get executed
            </script>

            üî¥ setTimeout + closures

        8.     // here after 3000 milli sec/ 3sec will print 1
                    <script>
                    function x() {
                        var i = 1;
                        setTimeout(function () {
                        console.log(i);
                        }, 3000);
                    }

                    x();
                    </script>

        9.     // here after 3000 milli sec/ 3sec will print 1
                    <script>
                        function x() {
                            var i = 1;
                            setTimeout(function () {
                            console.log(i);
                            }, 3000);
                            console.log("Namaste JS")
                        }

                        x();
                    </script>

                    after 3 sec => 1 => Namaste JS  ‚ùå
                    namste js => after 3 sec => 1   ‚úÖ

                    here setTimeout forms closures with lexical env,
                    it takes the function and stores it in some other place & attach timer to it & wait for expiry.

                    TIME, TIDE AND JS WAITS FOR NONE.

        10.   // same memory loaction geting updated
                     <script> 
                        // because of var, function looks for the reference of (i) in memory location 

                        function x(){
                            for(var i = 1; i <= 5 ; i++){
                            setTimeout(function() {
                                console.log(i)
                            }, i * 1000);
                            }
                            console.log("Namaste JS")
                        }

                        x()

                        // Namaste jS 
                        // 6,6,6,6,6
                    </script>

        11.   // Different memory location allocated because of let.
                     <script> 

                        function x(){
                            for(let i = 1; i <= 5 ; i++){
                            setTimeout(function() {
                                console.log(i)
                            }, i * 1000);
                            }
                            console.log("Namaste JS")
                        }

                        x()

                        // Namaste jS 
                        // 1,2,3,4,5
                    </script>

        12.   // Different execution context created with closures each time having new var value.
                     <script> 
                               function x() {
                                    for (var i = 1; i <= 5; i++) {
                                    function close(x) {
                                        setTimeout(function () {
                                        console.log(x);
                                        }, x * 1000);
                                    }
                                    close(i);
                                    }
                                    console.log("Namaste JS");
                                }

                                x();

                         // Namaste jS 
                        // 1,2,3,4,5

                    </script>

             üî¥ Interview [closures]

        13.     <script>
                    function outer(){
                    var a =10;
                        function inner(){
                        console.log(a)         // 10
                        }
                        return inner
                    }

                    outer()()
                </script>

        14.     <script>
                    function outer(){
                        var a =10;
                            function inner(){
                            console.log(a)        // 10
                            }
                            return inner
                        }

                        var close = outer()
                        close()
                </script>

        15.     <script>
                    function outer(){
                        function inner(){
                        console.log(a)         // 10
                        }
                        var a =10;
                        return inner
                    }

                    var close = outer()
                    close()
                </script>

        16.     <script>
                    function outer(){
                        let a =10;
                            function inner(){
                            console.log(a)      // 10
                            }
                            return inner
                        }

                        var close = outer()
                        close()
                </script>

        17.     <script>
                    function outer(b){
                        let a =10;
                            function inner(){
                            console.log(a, b)      // 10 'Namaste Duniya'
                            }
                            return inner
                        }

                        var close = outer("Namaste Duniya")
                        close()
                </script>


        18.     <script>
                    function outest() {
                        let c = 20;
                        function outer(b) {
                        let a = 10;
                        function inner() {
                            console.log(a, b, c);      // 10 'Namaste Duniya' 20
                        }
                        return inner;
                        }
                        return outer;
                    }

                    var close = outest()("Namaste Duniya");
                    close();
                </script>

        19.     <script>
                    function outest() {
                        let c = 20;
                        function outer(b) {
                        function inner() {
                            console.log(a, b, c);      // 10 'Namaste Duniya' 20
                        }
                        let a = 10;
                        return inner;
                        }
                        return outer;
                    }
                    let a = 100;

                    var close = outest()("Namaste Duniya");
                    close();
                </script>

        20.     <script>
                    function outest() {
                        let c = 20;
                        function outer(b) {
                        function inner() {
                            console.log(a, b, c);     // 100 'Namaste Duniya' 20
                        }
                        return inner;
                        }
                        return outer;
                    }
                    let a = 100;

                    var close = outest()("Namaste Duniya");
                    close();
                </script>

        21.     <script>
                    function outest() {
                        var c = 20;
                        function outer(b) {
                        function inner() {
                            console.log(a, b, c);      // 10 'Namaste Duniya' 20
                        }
                        let a = 10;
                        return inner;
                        }
                        return outer;
                    }

                    var c = 100;

                    var close = outest()("Namaste Duniya");
                    close();
                </script>

        22.     <script>
                    function outest() {
                        function outer(b) {
                            function inner() {
                                console.log(a, b, c);           // 10 'Namaste Duniya' 100
                            }
                        let a = 10;
                        return inner;
                        }
                        return outer;
                    }

                    var c = 100;

                    var close = outest()("Namaste Duniya");
                    close();
                </script>

        23.     <script>
                    function outest() {
                        var c = 20
                        function outer(b) {
                        function inner() {
                            console.log(a, b, c);    // Uncaught ReferenceError: a is not defined
                        }
                        return inner;
                        }
                        return outer;
                    }

                    var close = outest()("Namaste Duniya");
                    close();
                </script>

        // garbage collector : it is a program in a browser or js engine which frees up the unutilised memory.
           unused variable : It takes out of memory whenever it finds out that variable is no longer needed. 
----------------------------------------------------------------------------------------------------------------------------
ü§î Normal function vs arrow function ?

üÖ∞Ô∏è    ‚úÖ code snippet 1  (normal function/ function statement/ function declaration)
            a()   ‚úÖ
           function a(){
                console.log("a called")
            }

      ‚úÖ code snippet 2  (arrow function/ function expression/ function acts like a value)

              b()      ‚ùå
              var b = function(){
                    console.log("b callled")      // TypeError: b is not a function 
                }

              ba()     ‚ùå
              var ba = ()=>{
                  console.log("b callled")
              }

              

        Difference btn code snippet 1 & 2 is "Hoisting", code snippet 2 behave like a variable having a value.
        see the function calling position in both the code snippet.
----------------------------------------------------------------------------------------------------------------------------
ü§î. types of function ?
üÖ∞Ô∏è  üî¥Void function: functions which does not return anything, they just display value.
     üî¥anonymous Function

        eg: function(){
                  
                }

    üî¥first class function (eg: shown in respective question )
    üî¥call back function  (eg: shown in respective question )
    üî¥Higher order function  (eg: shown in respective question )
    üî¥arrow function (eg: shown in respective question )
    üî¥pure function  (eg: shown in respective question )
    üî¥function statement == function declaration (eg: shown in respective question )
    üî¥function expression (eg: shown in respective question )
    üî¥Named function expression

        eg: var b = function xyz(){
                    console.log("function called")
                }

                b()
                xyz()    // ReferenceError: xyz is not defined


        eg: var b = function xyz(){
                    console.log(xyz)     // ∆í xyz(){
                                         //  console.log(xyz)
                                         //    }
                  }

                 b() 



----------------------------------------------------------------------------------------------------------------------------
ü§î How many ways you can pass arguments to the functions ?
üÖ∞Ô∏è   ‚úÖ Positional Arguments
            Arguments are passed based on the position they appear in the function call.
            The first value goes to the first parameter, second to the second, and so on.

                function add(a, b) {
                    return a + b;
                    }
                    add(2, 3); // 2 is assigned to a, 3 to b

      ‚úÖ Default Parameters - Used to provide default values for parameters if no argument (or undefined) is passed.
                 
                 function greet(name = "Guest") {
                    console.log(`Hello, ${name}`);
                    }
                    greet();       // Hello, Guest
                    greet("Sam");  // Hello, Sam

        ‚úÖ  Rest Parameters - Allows a function to accept an indefinite number of arguments as an array. Syntax: ...rest

                    function sum(...numbers) {
                        return numbers.reduce((a, b) => a + b, 0);
                        }
                        sum(1, 2, 3); // 6

        ‚úÖ Arguments Object
                An array-like object available inside functions (non-arrow functions).
                Contains all arguments passed to the function, regardless of the defined parameters.
                ‚ùå Not allowed in arrow function.
                
                It's a built-in object available inside non-arrow functions.
                It contains an array-like collection of all arguments passed to the function, regardless of how many parameters the function declares.

                function showArguments() {
                    console.log(arguments);       // [Arguments] { '0': 'apple', '1': 'banana', '2': 'cherry' }
                    }

                    showArguments("apple", "banana", "cherry");


                function showArgs() {
                    for (let i = 0; i < arguments.length; i++) {
                        console.log(arguments[i]);
                    }
                    }
                    showArgs("a", "b", "c");

        ‚úÖ  Object as Parameter (Named Arguments)
                A single object is passed to the function with named properties.
                Useful for functions with many optional parameters.

                function createUser({ name, age }) {
                    console.log(name, age);
                    }
                    createUser({ name: "John", age: 25 });

        ‚úÖ  Array as Parameter
                Pass an array directly and access values via indexing or destructuring.

                function processData([a, b]) {
                        console.log(a, b);
                        }
                        processData([10, 20]); // 10 20

        ‚úÖ Function as Argument (Callback)
                Functions can accept other functions as arguments and invoke them.

                function executor(callback) {
                        callback();
                        }
                        executor(() => console.log("Hello from callback"));

-----------------------------------------------------------------------------------------------------------------------------
ü§î How to use default parameters in function ?

üÖ∞Ô∏è Alraedy Done.
------------------------------------------------------------------------------------------------------------------------------
ü§î pure vs Impure function ?

üÖ∞Ô∏è     ‚úÖ Pure Functions

            Always returns the same output for the same input.
            Does not cause any side effects (e.g., modifying global variables, DOM, files, etc.).

            characteristics:
            Deterministic: Same input ‚Üí Same output.
            No side effects: Doesn‚Äôt change external state.
            Testable and predictable.

              function add(a, b) {
                    return a + b;
                    }

            add(2, 3) will always return 5, no matter when or where it's called.

        ‚úÖ Impure Functions

              May return different outputs for the same inputs.
              Causes side effects ‚Äî like modifying external variables, I/O, or state.

               Side Effects Examples:
                    Changing a global variable
                    Logging to console
                    Writing to a file or DB
                    Fetching API data
                    Modifying DOM

                let count = 0;
                    function increment() {
                    count++;
                    return count;
                    }

                Calling increment() will give different results each time because it mutates external state (count).

                function getDate() {
                    return new Date();
                    }

                Seems pure, but returns different output every time ‚Üí impure.

                function square(x) {
                    console.log(x); // side effect
                    return x * x;
                    }

                Output is consistent, but console.log is a side effect ‚Üí impure.

                function double(arr) {
                    arr[0] = arr[0] * 2;
                    return arr;
                    }

                Modifies input array ‚Üí side effect ‚Üí impure.

                function getRandom() {
                    return Math.random();
                    }

                Non-deterministic output ‚Üí impure.

            ‚úÖ Bonus Tip: How to Spot a Pure Function?

                Ask yourself:
                ‚ùì Does it depend only on its inputs?
                ‚ùì Does it modify anything outside its scope?
                ‚ùì Will it always give the same result for the same input?
                        If YES ‚Üí Pure
                        If NO ‚Üí Impure


------------------------------------------------------------------------------------------------------------------------------
ü§î first class function ?

üÖ∞Ô∏è A function that can be treated like any other variable in a programming language. This mean that it can be passed
    as an argument to another function, returned as a value from a function, & assigned to a variable.
    Also known as first class citizen function.

    üìå Stored in a Variable
            const sayHello = function() {
                    console.log("Hello!");
                };

                sayHello(); // ‚úÖ Output: Hello!

    üìå Passed as an Argument
            function greet(name, callback) {
                    console.log("Hi, " + name);
                    callback(); // Call the passed function
                }

                function sayGoodbye() {
                    console.log("Goodbye!");
                }

                greet("Alice", sayGoodbye);

                // ‚úÖ Output:
                // Hi, Alice
                // Goodbye!

            üëâ We're passing a function (sayGoodbye) as an argument to another function (greet).

    üìå Returned from Another Function
                function multiplier(factor) {
                    return function(number) {
                        return number * factor;
                    };
                }

                const double = multiplier(2);
                console.log(double(5)); // ‚úÖ Output: 10

            üëâ multiplier returns another function, and we store it in double.

----------------------------------------------------------------------------------------------------------------------------
ü§î callback function ?

üÖ∞Ô∏è A function that is passed as an argument to another functiion and is executed inside the function it was passed to it.
    The purpose of a callback functiion is to allow the caller to specify what action should be taken after the
    function it was passed to has completed its task.

      function greetUser(name, callback) {
                console.log("Hi " + name);
                callback();
            }

            function sayBye() {
                console.log("Bye!");
            }

            greetUser("Alice", sayBye);

            // ‚úÖ Output:
            // Hi Alice
            // Bye!

     üëâ sayBye is a callback function passed into greetUser.
----------------------------------------------------------------------------------------------------------------------------
ü§î Higher order function ?

üÖ∞Ô∏è A function that takes one or more functions as arguments and/or returns a function as its result. It is called
    "higher order" bcoz it operates on other functions, either byy taking them as arguments or by returning them as
    results. Hogher order functions are often used to create abstractions that can be reused accross multiple parts 
    of a program

    function multiplyBy(factor) {
            return function(num) {
                return num * factor;
            };
        }

        const double = multiplyBy(2);
        console.log(double(5)); // ‚úÖ Output: 10

    üëâ multiplyBy is a higher-order function because it returns another function.
----------------------------------------------------------------------------------------------------------------------------
ü§î map, reduce, filter ?

üÖ∞Ô∏è Things to be learned :
     1. map method is used when we want transformation of whole array
     2. filter is used when we want to filter the array to obtain required value.
     3. reduce is used when we want to reduce the array to single value (eg: max, min, avg, sum, difference etc)
     4. reduce passes 2 arguments one function(which includes accumulator and current element of array) and another
          innitial value of accummulator

     üìå map
         eg:- 1     const arr = [5,1,3,2,6]

                    function double(x){
                        return x * 2
                    }

                    const output = arr.map(double)
                    console.log(output)            // [ 10, 2, 6, 4, 12 ]

        eg:- 2       const arr = [5,1,3,2,6]

                        function binary(x){
                            return x.toString(2)
                        }

                        const output = arr.map(binary)
                        console.log(output)             // [ '101', '1', '11', '10', '110' ]

        eg:- 3        const arr = [5,1,3,2,6]

                        const output = arr.map(function binary(x){
                            return x.toString(2)
                        })

                        console.log(output)           // [ '101', '1', '11', '10', '110' ]

        eg:- 4          const arr = [5,1,3,2,6]

                        const output = arr.map((x)=>{   via => variable, index, array
                            return x.toString(2)
                        })

                        console.log(output)               //  // [ '101', '1', '11', '10', '110' ]

    üìå filter
           eg:- 1
                        const arr = [5,1,3,2,6]

                        function isOdd(x){
                            return x % 2
                        }

                        const output = arr.filter(isOdd)
                        console.log(output)                   // [ 5, 1, 3 ]

           eg:- 2       const arr = [5,1,3,2,6]

                        function isEven(x){
                            return x % 2 === 0
                        }

                        const output = arr.filter(isEven)
                        console.log(output)                   // [ 2, 6 ]

           eg:- 3       const arr = [5,1,3,2,6]

                        function greaterThan4(x){
                            return x > 4
                        }

                        const output = arr.filter(greaterThan4)
                        console.log(output)                      // [ 5, 6 ]

           eg:- 4       const arr = [5,1,3,2,6]

                        const output = arr.filter((x)=>{
                            return    x < 3
                        })
                        console.log(output)                   // [ 1, 2 ]

    üìå reduce 
            eg:- 1      const arr = [5,1,3,2,6]

                        const output = arr.reduce(function(acc, curr){
                            acc = acc + curr
                            return  acc
                        }, 0)

                        console.log(output)              // 17

            eg:- 2      const arr = [5,1,3,2,6]

                        const output = arr.reduce(function(acc, curr){
                            if(curr > acc){
                                acc = curr
                            }
                            return  acc
                        }, 0)

                        console.log(output)                // 6

            eg:- 3      const users = [
                            {firstName: "akshay", lastName: "saini", age: 26},
                            {firstName: "donald", lastName: "trump", age: 75},
                            {firstName: "elon", lastName: "musk", age: 50},
                            {firstName: "deepika", lastName: "padukone", age: 26}
                            ]
                            
                                const output = users.map((x)=>{
                                return  x.firstName + " " + x.lastName
                                })

                                console.log(output)    // [ 'akshay saini', 'donald trump', 'elon musk', 'deepika padukone' ]


            eg:- 4       const users = [
                                {firstName: "akshay", lastName: "saini", age: 26},
                                {firstName: "donald", lastName: "trump", age: 75},
                                {firstName: "elon", lastName: "musk", age: 50},
                                {firstName: "deepika", lastName: "padukone", age: 26}
                                ]
                                
                            const output = users.reduce(function(acc, curr){
                                if(acc[curr.age]){
                                    acc[curr.age] = ++ acc[curr.age]
                                }else{
                                    acc[curr.age] = 1
                                }
                                return acc
                            }, {})

                            console.log(output)       // { '26': 2, '50': 1, '75': 1 }

            eg:- 5          const users = [
                                {firstName: "akshay", lastName: "saini", age: 26},
                                {firstName: "donald", lastName: "trump", age: 75},
                                {firstName: "elon", lastName: "musk", age: 50},
                                {firstName: "deepika", lastName: "padukone", age: 26}
                                ]
                                
                            const output = users.filter((x)=> x.age < 30).map((x)=> x.firstName)

                            console.log(output)       // [ 'akshay', 'deepika' ]
 

----------------------------------------------------------------------------------------------------------------------------
ü§î  IIFE ?

üÖ∞Ô∏è   ‚úÖ What is an IIFE?
        IIFE stands for Immediately Invoked Function Expression.
        It is a function that runs as soon as it is defined.
        It‚Äôs a design pattern used to create a private scope in JavaScript.

    ‚úÖ How does it work?
          (function() {
            // code here
            })();

            (() => {
                // code here
                })();

            The outer parentheses () turn the function declaration into an expression.
            The second () immediately invokes the function.

     ‚úÖ Why use an IIFE?
             Create private scope	Avoid polluting the global namespace
             Encapsulation	Encapsulate variables to avoid conflicts
             Module pattern (pre-ES6)	Used to simulate modules before ES6 introduced import/export
             Immediate execution	Useful for code that runs once (e.g., init setup)

    ‚úÖ When should you use IIFE?
            When you want to execute code immediately during script load.
            When you need to protect variables from leaking into the global scope.
            In legacy JS (ES5 or earlier) where modules weren't available.
            When writing a self-contained utility block or one-time setup code.

    ‚ö†Ô∏è Edge Cases / Corner Cases with IIFE
            1. Forgetting to wrap in parentheses
                function() {
                    // invalid syntax ‚ùå    Fix: Wrap in () to make it a function expression.
                    }();  

            2. Arrow function IIFE and this context
                (() => {
                    console.log(this); // `this` is lexical, not dynamic
                    })();

                In arrow functions, this is not bound to the function ‚Äî it takes this from the surrounding scope.

            3. IIFE return value capturing
                const result = (function(x, y) {
                    return x + y;
                    })(2, 3);

                    console.log(result); // 5 
                You can store the result of an IIFE in a variable.

----------------------------------------------------------------------------------------------------------------------------
ü§î Currying function ?

üÖ∞Ô∏è  ‚úÖWhat is Function Currying?
        Definition: Currying is a functional programming technique where a function with multiple arguments 
        is transformed into a sequence of functions each taking a single argument.

        Instead of calling f(a, b, c), you call f(a)(b)(c).

    ‚úÖHow does Currying work in JavaScript?
        In JavaScript, currying can be implemented using closures.

        It returns nested functions, each capturing the argument and returning another function until all arguments are provided.

        eg 1:- // Normal function
                    function add(a, b, c) {
                    return a + b + c;
                    }

                    // Curried version
                    function curriedAdd(a) {
                    return function(b) {
                        return function(c) {
                        return a + b + c;
                        };
                    };
                    }

                    // Usage
                    curriedAdd(1)(2)(3); // 6

        eg 2:- let multiply = function(x){
                    return function (y){
                        return function(z){
                            console.log(x + y + z)         // 9
                        }
                    }
                }

                multiply(2)(3)(4);

        eg 3:-  let multiply = function(x){
                        return function (y){
                            return function(z){
                                console.log(x + y + z)     // 9
                            }
                        }
                    }

                    let res1 = multiply(2)
                    let res2 = res1(3)
                    res2(4)

    ‚úÖ Why use Function Currying?
            Reusability: Create specialized versions of functions.
            Function composition: Makes code more readable and composable.
            Partial application: You can pass some arguments now and the rest later.
            Helps with functional programming patterns.

    ‚úÖ When to use Currying?
            When dealing with functional pipelines, like in React, Redux, or Ramda.js.
            Useful in event handlers, form validations, or middleware patterns where parameters are passed in stages.

----------------------------------------------------------------------------------------------------------------------------
ü§î callback hell ?

üÖ∞Ô∏è   good and bad parts of callbacks in JavaScript.
        Good part of callbacks: essential for handling asynchronous operations in JavaScript by allowing code to execute later.
        bad parts of callbacks: callback hell(pyramid of doom) horizontal expansion of code, inversion of control

        Inversion of control: when callbacks are passed to other functions, developers lose control over the execution of the code,
        which can lead to issues like callbacks not being called or being called multiple times.

        üß† Context: Making a Pizza (Step-by-step)
                You're building a pizza-making app where:
                You start making the dough
                Then you add toppings
                Then you bake the pizza
                Then you serve the pizza
            Each step takes time (asynchronous), and must wait for the previous step to complete.

        function makeDough(callback) {
        setTimeout(() => {
            console.log("1. Dough is ready");
            callback();
        }, 1000);
        }

        function addToppings(callback) {
        setTimeout(() => {
            console.log("2. Toppings added");
            callback();
        }, 1000);
        }

        function bakePizza(callback) {
        setTimeout(() => {
            console.log("3. Pizza is baked");
            callback();
        }, 1000);
        }

        function servePizza() {
        setTimeout(() => {
            console.log("4. Pizza is served üçï");
        }, 1000);
        }

        // Callback Hell starts here (nested callbacks)
        makeDough(function () {
        addToppings(function () {
            bakePizza(function () {
            servePizza();
            });
        });
        });

        üß† Why it's "Callback Hell"
                Notice how each function is nested inside the previous one.
                The code is moving to the right with each step ‚Üí hard to read and maintain.
                Imagine if there were 10 steps üò¨ ‚Äî it would get messy fast!


----------------------------------------------------------------------------------------------------------------------------
ü§î Promises, promises stage/state ?

üÖ∞Ô∏è Before promises, developers used callbacks to handle async operations,
    but this created an "inversion of control" problem where you blindly trust external code to call your callback.

    With promises, API returns a promise object that initially contains undefined data but 
    will eventually be filled with the result of the async operation.

    Instead of passing callbacks to functions, you attach callbacks to promise objects using .then(),
    which guarantees the callback will be called exactly once when data is available.

    Promises have three possible states: pending (initial state), fulfilled (successful completion), or rejected (failed operation).
          ‚úÖ resolve, success, fulfilled.
          ‚ùå reject, failure, rejected.

    A promise is defined as "an object representing eventual completion of an async operation."

    Promises solve the "callback hell" problem by allowing chaining with .then() methods, 
    transforming horizontal nested callbacks into a vertical, more readable chain.

    Key advantages of promises: they maintain control of your program flow, guarantee callbacks are called exactly once, 
    and provide a more readable way to handle asynchronous operations.

    HERE WE ARE CONSUMING PROMISE

            function makeDough() {
        return new Promise((resolve) => {
            setTimeout(() => {
            console.log("1. Dough is ready");
            resolve();
            }, 1000);
        });
        }

        function addToppings() {
        return new Promise((resolve) => {
            setTimeout(() => {
            console.log("2. Toppings added");
            resolve();
            }, 1000);
        });
        }

        function bakePizza() {
        return new Promise((resolve) => {
            setTimeout(() => {
            console.log("3. Pizza is baked");
            resolve();
            }, 1000);
        });
        }

        function servePizza() {
        return new Promise((resolve) => {
            setTimeout(() => {
            console.log("4. Pizza is served üçï");
            resolve();
            }, 1000);
        });
        }

        // Promise chaining - much cleaner and avoids callback hell
        makeDough()
        .then(() => addToppings())
        .then(() => bakePizza())
        .then(() => servePizza());

        // Alternative more concise syntax:
        // makeDough()
        //   .then(addToppings)
        //   .then(bakePizza)
        //   .then(servePizza);

        The key changes:

        Each function now returns a Promise instead of accepting a callback
        Inside each function, we wrap the setTimeout in a Promise constructor with a resolve function
        We call resolve() when the operation completes to signal success
        We chain the functions using .then() which creates a clean, vertical flow
        The alternative syntax shows you can directly pass function references when not needing to modify parameters
----------------------------------------------------------------------------------------------------------------------------
ü§î  how to create custom Promises, implement proper error handling, and manage asynchronous operations effectively ?

üÖ∞Ô∏è HARE WE ARE CREATING PROMISE

    Promises in JavaScript follow a producer-consumer model where one part of the code creates and resolves/rejects a Promise
     while another part consumes it by attaching callbacks. 

                // Step 1: Make Dough
            function makeDough() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                console.log("1. Dough is ready");
                resolve(); // Everything is good, so we resolve the Promise
                }, 1000);
            });
            }

            // Step 2: Add Toppings
            function addToppings() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                const isToppingAvailable = true; // change to false to simulate an error
                if (isToppingAvailable) {
                    console.log("2. Toppings added");
                    resolve();
                } else {
                    reject("No toppings available!");
                }
                }, 1000);
            });
            }

            // Step 3: Bake Pizza
            function bakePizza() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                console.log("3. Pizza is baked");
                resolve();
                }, 1000);
            });
            }

            // Step 4: Serve Pizza
            function servePizza() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                console.log("4. Pizza is served üçï");
                resolve();
                }, 1000);
            });
            }

            // Chaining promises with error handling
            makeDough()
            .then(() => {
                return addToppings(); // if this fails, it will jump to catch block
            })
            .then(() => {
                return bakePizza();
            })
            .then(() => {
                return servePizza();
            })
            .catch((error) => {
                // This will run if any of the above promises reject
                console.error("‚ùå There was an error making your pizza:", error);
            });

----------------------------------------------------------------------------------------------------------------------------
ü§î promise API ?

üÖ∞Ô∏è  Promise.all(),
    Promise.allSettled()
    Promise.race()
    Promise.any()

    are used in JavaScript to handle multiple promises in parallel, often used for parallel API calls.

üìå Promise.all([p1, p2, p3]) - fail fast, It will not wait for other promises.
    output of api call array (good case)
    result p1 -> 3sec ‚úÖ
    result p2 -> 1sec ‚úÖ
    result p3 -> 2sec ‚úÖ

    we get output after 3sec because all calls are parallel & wait all of them to finish & then collect result & gives output.

    output of api call array (bad case)
    result p1 -> 3sec ‚úÖ
    result p2 -> 1sec ‚ùå
    result p3 -> 2sec ‚úÖ

    Immediately as soon as any of the promise gets rejected promise.all() throw error & whatever error thrown by promise same
    is in output we will get.
    & whatever time that rejected promise taking after that only we get output didn't wait for other to finish other will 
    execute but we already get result output as soon as anyone fails, here just after 1sec.

    Use when all results are required and you want to fail fast.

üìå Promise.allSettled([p1, p2, p3])
    output of api call array (good case)
    result p1 -> 3sec ‚úÖ
    result p2 -> 1sec ‚úÖ
    result p3 -> 2sec ‚úÖ

    output of api call array (bad case)
    result p1 -> 3sec ‚úÖ
    result p2 -> 1sec ‚úÖ
    result p3 -> 2sec ‚ùå

    Here even If any promise fail, it didn't through error directly it will wait for other to finish their call execution
    & then gives array will all result & error output.

    output = ([result p1, result p2, error p3]) after 3 sec

    Use when you want all results, regardless of success or failure.

üìå Promise.race([p1, p2, p3]) - result of 1st settled promise - success/fail
    output of api call array (good case) => resultp2
    result p1 -> 3sec ‚úÖ
    result p2 -> 1sec ‚úÖ
    result p3 -> 2sec ‚úÖ

    as soon as 1st promise resolve, it will give result of that particular promise value not array

    Resolves or rejects as soon as the first promise settles.
    Use when you're interested in only the first result, e.g., fastest response or timeout race.

üìå Promise.any([p1, p2, p3]) - result of 1st success promise (success seeking)
    output of api call array (good case) => resultp2
    result p1 -> 3sec ‚úÖ
    result p2 -> 1sec ‚úÖ
    result p3 -> 2sec ‚úÖ

    Resolves as soon as any promise resolves.
    Ignores rejections unless all fail, then it rejects with an AggregateError.
    Use when you just need any successful result.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î async await ?

üÖ∞Ô∏è  async/await
       ‚¨áÔ∏è
    wraps value in promise (if it is already in promise then he won't wrap again in promise) 
       ‚¨áÔ∏è 
    for consuming promise we convert it into readable
       ‚¨áÔ∏è 
    then we use that value in our code.


    // Define an async function
        async function fetchUserData() {
        try {
            // Await the fetch call
            const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
            
            // Await the conversion of response to JSON
            const data = await response.json();
            
            // Log the user data
            console.log('User Data:', data);
        } catch (error) {
            // Handle any errors
            console.error('Error fetching data:', error);
        }
        }

    // Call the async function
        fetchUserData();
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ü§î Difference between promise & async await ?

 üÖ∞Ô∏è  üìå  let myPromise = new Promise((resolve, reject)=>{

        let success =  true;

        console.log("before promise")
        setTimeout(()=>{
            if(success){
                resolve("operation succesfully")
                console.log("In promise")
            }else{
                reject("operation failed")
            }
        }, 5000)

        console.log("After promise")
        })

        myPromise.then((result) => console.log(result))      // operation succesfully
        .catch((error)=> console.log(error))                 // operation failed

        // PROGRAM FLOW :-

        // before promise
        // After promise
        // operation successfull

        // JS waits for none so until then promise is completing it runs other things

        üü© Explanation:
            Creates a Promise which resolves or rejects after 5 seconds.
            Logs before promise and after promise immediately, because creating a Promise is synchronous.
            When the Promise is fulfilled after 5 seconds, .then() is called.
            If it were to reject, .catch() would handle it.
            This code demonstrates non-blocking behavior ‚Äî code after the promise runs immediately while the async operation continues in the background.

        // Async/Await is Better for simplicity and Readablility: If you are working with asynchronous code that involves sequential operation,
         async/await is generally the preferred approach because it makes the code look like its synchronous (which is easier to follow and debug)

        // Promise are useful for parallelism and complex flows: If you're dealing with multiple asynchronous operation that don't depend on each other
         (or need to run in parallel), Promises and methods like Promise.all() or Promise.race() are label.


    üìå let myPromise = new Promise((resolve, reject) => {

        let success = true;

        setTimeout(() => {
          if (success) {
            resolve("operation successfull");
          } else {
            reject("operation failed");
          }
        }, 5000);
      });

      myPromise
        .then((result) => console.log(result)) // "operation successfull"
        .catch((error) => console.log(error)); // operation failed

      async function asyncFunction() {
        try {
          console.log("Before async await");

          let result = await myPromise; //  waits for the promise to resolve or reject
          console.log("After1 async await");
          console.log(result); // operation successfull
          console.log("After2 async await");
        } catch (error) {
          console.log(error); // operation failed
        }
      }

      asyncFunction();

      // PROGRAM FLOW:
      
      // before async await
      // operation successfull
      // After1 async await
      // operation successfull
      // After2 async await

      // after 5 sec other things after wait will execute so here JS engine wait for promise to resolve & after that only it will run in sequence but then/catch it 
          didn't wait for promise to resolve.

      üü© Explanation:
            Same myPromise is used, but now also consumed with async/await.
            asyncFunction() logs Before async await, then waits for myPromise to resolve.
            When the promise resolves, it logs After1 async await, then the result, then After2 async await.
            If the promise had rejected, the catch block inside asyncFunction would handle it.
            This shows synchronous-style coding for asynchronous operations, making code easier to read and maintain.

      // Async/Await is Better for simplicity and Readablility: If you are working with asynchronous code that involves sequential operation,
       async/await id generally the preferred approach because it makes the code look like its synchronous (which is easier to follow and debug)

      // Promise are useful for parallelism and complex flows: If you're dealing with multiple asynchronous operation that don't 
      depend on each other (or need to run in parallel), Promises and methods like Promise.all() or Promise.race() are label.

üî¥  Execution Flow	Non-blocking, continues immediately	Awaits/pause within async functions
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
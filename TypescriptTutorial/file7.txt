15th - Interface vs Type

Interfaces in TypeScript are more than just object blueprints â€” they support extension, merging, and inheritance, 
making them powerful for modeling complex systems and working with external libraries.

ğŸ”‘ Key Concepts Discussed

1. Reopening Interfaces:

You can declare an interface multiple times and add properties to it later (useful when working with third-party libraries).
Commonly referred to as interface augmentation or "reopening the interface" (even if itâ€™s just syntactic sugar).

2. Interface Inheritance using extends:

Interfaces can extend other interfaces to reuse and combine structure.
Enables hierarchical modeling of data (e.g., Admin extends User).

3. Difference Between Interface vs Type (brief mention):

Interfaces can be reopened.
Types are static after declaration.
Inheritance in types uses &, whereas interfaces use extends.

// âœ… Step 1: Initial interface
interface User {
  email: string;
  userId: number;
  googleId?: string;
  readonly dbId: number;
  startTrial(): string;
}

// âœ… Step 2: Reopen (augment) interface to add new property
interface User {
  githubToken: string;
}

// âœ… Usage of the extended interface
const devUser: User = {
  email: "user@example.com",
  userId: 123,
  dbId: 456,
  githubToken: "gho_xxx123",
  startTrial: () => "Trial Started!",
};

// âœ… Step 3: Inherit interface using `extends`
interface Admin extends User {
  role: "admin" | "TA" | "learner";
}

// âœ… Admin object using inherited fields
const adminUser: Admin = {
  email: "admin@example.com",
  userId: 999,
  dbId: 111,
  githubToken: "gho_admin999",
  startTrial: () => "Admin Trial Started!",
  role: "admin", // must be one of the defined literal types
};

ğŸ§µ Cheat Sheet Summary

ğŸ’¡ Use `interface` for:
  - Object shapes
  - Class implementations
  - Declaration merging
  - Extending multiple object types cleanly

ğŸ§¬ Use `type` for:
  - Primitives (type ID = string)
  - Tuples (type RGB = [number, number, number])
  - Unions (type Status = "success" | "fail")
  - Intersections (type Admin = User & Role)


  Feature	                   interface	                                   type

  Basic Syntax	               interface User { name: string }	              type User = { name: string }

  Extending/Inheritance	       extends keyword	                              & (intersection operator)

  Reopening/Declaration        âœ… Allowed (can add fields later)             âŒ Not allowed (once declared, fixed)
  Merging	

  Use for Objects	           Preferred for object shapes	                   Also fine

  Use for Primitives,          âŒ Not supported                               âœ… Can represent union, primitives, tuples
  Tuples, etc		

  Implements in Classes	       âœ… Classes can implement an interface	         âœ… Classes can implement types too (object shapes only)
  
------------------------------------------------------------------------------------------------------------------------------------
16th - private public in TS

ğŸ”‘ Core Concepts Covered:
1. Access Modifiers (public and private):

public: Default in TypeScript. All properties/methods are public unless otherwise specified.
private: Restricts access within the class only. External access is not allowed.

2. JavaScript-style privacy (#) vs TypeScript-style (private):

#property is the native JavaScript way of marking a property private.
private property is TypeScript-specific and preferred for better readability and tooling support.

3. Constructor Parameter Shorthand:

You can define and initialize properties directly in the constructor parameters using public, private, or readonly.

4. Cleaner Syntax for Class Properties:

Professional codebases often use constructor shorthand to reduce boilerplate code.

âŒ Traditional Verbose Way

class User {
  public email: string;
  public name: string;
  private city: string = "Mumbai";

  constructor(email: string, name: string) {
    this.email = email;
    this.name = name;
  }

  getCity() {
    return this.city;
  }
}


âœ… Clean Constructor Shortcut (Professional Practice)

class User {
  constructor(
    public email: string,
    public name: string,
    private city: string = "Mumbai",
    private readonly userId: string
  ) {}

  getCity() {
    return this.city;
  }
}

ğŸ”’ Access Control Example

const user = new User("a@example.com", "Alice", "Delhi", "user123");

console.log(user.email);     // âœ… Allowed (public)
console.log(user.name);      // âœ… Allowed (public)
console.log(user.getCity()); // âœ… Allowed via method
// console.log(user.city);   // âŒ Error: Property 'city' is private
// user.userId = "newId";    // âŒ Error: userId is readonly

ğŸ“Œ Final Takeaway
Learn to use TypeScriptâ€™s access modifiers effectively with constructor shorthand to write clean, 
secure, and professional class-based code.
------------------------------------------------------------------------------------------------------------------------------------
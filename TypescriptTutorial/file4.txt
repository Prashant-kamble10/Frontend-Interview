9th - Bad behaviour of objects in typescript

üî¥ TypeScript improves JavaScript's safety with types, but it doesn‚Äôt eliminate all of JavaScript‚Äôs quirks‚Äîespecially around object typing.

Specifically:

Object typing in TypeScript can enforce strict input and return structures in functions.

But, extra properties passed to functions directly are flagged as errors, while the same object passed via a variable is silently accepted.
This inconsistency is a known odd behavior in TypeScript.

// Function expecting only specific keys in object
function createUser(user: { name: string; isPaid: boolean }) {
  console.log("Creating user:", user);
}

// ‚ùå Directly passing extra property throws error
createUser({
  name: "Hitesh",
  isPaid: false,
  email: "hitesh@example.com", // ‚ùå TS Error: Object literal may only specify known properties
});

‚úÖ But here‚Äôs the odd behavior üëá

// ‚úÖ Defining the same object separately works (extra prop is allowed)
const newUser = {
  name: "Hitesh",
  isPaid: false,
  email: "hitesh@example.com" // Extra property
};

createUser(newUser); // ‚úÖ No error from TypeScript

‚ö†Ô∏è Why This Happens:
TypeScript does strict property checks on inline object literals, but is more lenient with variables, because of its structural typing system.

This can lead to unexpected bugs if developers assume extra properties will be rejected in all cases.
----------------------------------------------------------------------------------------------------------------------------------

10th - Type Aliases in Typescript

Type Aliases allow you to create custom type names for complex structures like objects, 
so you can reuse them across functions or modules‚Äîimproving readability, maintainability, 
and scalability of your TypeScript code.

Type Aliases help avoid repeating complex type structures (like objects with many properties).

They're especially helpful when multiple functions share the same data structure.

You define a type using the type keyword, followed by a name and structure.

// ‚úÖ 1. Define a type alias
type User = {
  name: string;
  email: string;
  isActive: boolean;
};

// ‚úÖ 2. Use it in a function parameter
function createUser(user: User): User {
  // Logic to modify or use user...
  return user; // ‚úÖ Return type is also 'User'
}

// ‚ùå 3. This will fail if structure is incomplete
// createUser({ name: "Alice" }); // ‚ùå Error: Missing 'email' and 'isActive'

// ‚úÖ 4. Correct usage
const newUser = {
  name: "Alice",
  email: "alice@example.com",
  isActive: true
};

createUser(newUser); // ‚úÖ No error

----------------------------------------------------------------------------------------------------------------------------------
what key message does this transcript gives ? 
also provide code snippet example
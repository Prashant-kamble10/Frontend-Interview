ü§î setTimout

1. What does setTimeout(fn, 0) actually mean? Does it execute fn immediately?

2. Can setTimeout guarantee exact timing of execution (e.g., exactly after 1000 ms)? Why or why not?

3. What happens if you pass a string instead of a function to setTimeout?

4. What does setTimeout return? How can you use it to cancel a scheduled function?  
=> It returns timerID (browser env), Returns a Timeout object (nodJS env)
    cancel a scheduled function through clearTimeout()

5. console.log(1);
setTimeout(() => console.log(2), 0);
console.log(3); 
What‚Äôs the output, and why?


6. for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
What will this log, and how would you fix it to print 0, 1, 2?


7. let count = 0;
const timer = setTimeout(() => {
  count++;
  console.log('Timer executed');
}, 1000);
clearTimeout(timer);
console.log(count);
What‚Äôs printed? Why?


8. setTimeout(() => console.log('Timeout 1'), 0);
Promise.resolve().then(() => console.log('Promise'));
console.log('Sync');
Explain the exact order of logs.


9. setTimeout(() => console.log('A'), 100);
setTimeout(() => console.log('B'), 50);
Will 'B' always log before 'A'?


10.How does JavaScript handle nested setTimeout calls for simulating intervals (e.g., recursive setTimeout vs. setInterval)?
What‚Äôs the advantage of recursive setTimeout?


11. let start = Date.now();
setTimeout(() => {
  console.log('Delay:', Date.now() - start);
}, 0);
while (Date.now() - start < 2000) {}
What output do you expect? Why is the delay not 0?


12. setTimeout(() => console.log('Timeout'), 0);
process.nextTick(() => console.log('Next Tick'));
Promise.resolve().then(() => console.log('Promise'));
What‚Äôs the output order? Why does Node behave this way?


13. How would you create your own version of setTimeout using setInterval?


14.let id = setTimeout(() => console.log('Run'), 1000);
id = setTimeout(() => console.log('Override'), 500);
clearTimeout(id);
Will anything print?
--------------------------------------------------------------------------------------------------------------------------------------
ü§î setTInterval

1. What does setInterval do, and how is it different from setTimeout?

2. Does setInterval(fn, 1000) guarantee that fn executes every exactly 1000ms? Why or why not? 
=>   console.log("start")

    setInterval(()=>{
    console.log("setInterval")
    }, 1000)

    let blockFor = Date.now() + 3000
    while(Date.now() < blockFor){}

    console.log("end")


     console.log("start")

    setInterval(()=>{

      let blockFor = Date.now() + 3000
    while(Date.now() < blockFor){}

    console.log("setInterval")
    }, 1000)
      console.log("end")
    

3. What does setInterval return, and how do you stop it?

4. What happens if the callback inside setInterval takes longer than the interval delay? (through blocking single thread & Callback Takes Longer Than Interval)
=> Timer drift
Time drift happens when the actual interval between executions of the callback function is longer than the specified interval time. This usually occurs when the main thread is blocked or the callback function takes longer to execute than expected. In such cases, the next invocation of the callback is delayed, and it can lead to the overall "drifting" of the scheduled times.


5. let i = 0;
const id = setInterval(() => {
  console.log(i++);
  if (i === 3) clearInterval(id);
}, 100);
What will be logged?


6. setInterval(() => console.log('A'), 0);
console.log('B');
What prints first? Why?


7. let x = 1;
setInterval(() => {
  x++;
  console.log(x);
}, 100);

setTimeout(() => {
  console.log("Timeout:", x);
}, 350);
What is printed by the timeout?


8. Why can setInterval sometimes ‚Äúpile up‚Äù callbacks?

9. let start = Date.now();

setInterval(() => {
  console.log("Interval fired at:", Date.now() - start);
}, 100);

while (Date.now() - start < 350) {}  // 350ms blocking
What do you expect the console output to look like?


10. Why is recursive setTimeout often considered better than setInterval?

11. let count = 0;
const id = setInterval(() => {
  console.log(count);
  count++;
  if (count === 1) clearInterval(id);
}, 100);
How many logs do we see?


12. setInterval(async () => {
  await new Promise(res => setTimeout(res, 200));
  console.log("Done");
}, 100);
Will this print every 100ms? What happens?


13. Does clearing an interval inside its own callback stop future executions immediately or after the current callback finishes?
=> Clearing an interval inside its own callback does not stop the current callback because it‚Äôs already running on the call stack.
It only prevents the interval from scheduling future executions.


14. Why might this interval never run in a Node.js server?

while (true) {
  // accidental infinite loop
}

setInterval(() => console.log("Ping"), 1000);

15. How would you implement your own version of setInterval using recursive setTimeout?
---------------------------------------------------------------------------------------------------------------------------------------
ü§î callbacks

1. What is a callback function in JavaScript, and why do we use it?

üÖ∞Ô∏è A function that is passed as an argument to another functiion and is executed inside the function it was passed to it.
    The purpose of a callback functiion is to allow the caller to specify what action should be taken after the
    function it was passed to has completed its task.
    Basically it helps to perform asynchronous task

2. What is the difference between: doSomething(callback); and  doSomething(callback());

üÖ∞Ô∏è   code 1 :

      function main(cb){
          console.log("main function")
          cb()
      }

      function callback(){
          console.log("callback function")
      }

      main(callback)      

      output : main function
              callback function

      main(callback) passes the function itself, not executed yet.
      Inside main, it prints "main function".
      cb() executes the callback function.
      Callback prints "callback function".

      code 2 : 

      function main(cb){
          console.log("main function")
          cb
      }
      function callback(){
          console.log("callback function")
      }
      main(callback())

       output : callback function
                main function

        callback() is executed immediately, before calling main.
        So "callback function" prints first.
        Whatever callback() returns (undefined) is passed to main.
        Inside main, it prints "main function".
        cb (undefined) is not executed, because no ().

      code 3 : 

      function main(cb){
            console.log("main function")
            console.log(cb)
          }

          function callback(){
            console.log("callback function")
          }

          main(callback())

        output : callback function
                  main function
                  undefined

        main(callback()) means execute callback() immediately.
        callback() runs before main():
        It prints: "callback function".
        It returns undefined (because no return statement).
        That undefined value becomes the argument cb for main.
        Inside main(cb):
        It prints "main function".
        It prints the value of cb, which is undefined.
                  
      code 4 : 

       function main(cb){
          console.log("main function")
                console.log(cb)
        }
        function callback(){
          return 2
        }
        
        main(callback())

        output : main function
                  2

        callback() is executed before calling main.
        callback() returns 2.
        That value (2) is passed as cb to main.
        Inside main, it prints "main function".
        Then it prints the value of cb, which is 2.
              

3. Why are callbacks important in asynchronous programming?

üÖ∞Ô∏è Non-blocking: JavaScript is single-threaded, so callbacks let it continue execution without waiting for slow tasks.
    Async result handling: They run only when an asynchronous task (API call, file read, timer) finishes.
    Concurrency: Enable the program to do other work while async operations run in the background.
    Foundation of modern async: Promises and async/await are built on top of callbacks.
    Event-driven behavior: Used to respond to events like clicks, network responses, and timers.

4. function greet(name, callback) {
      console.log("Hello", name);
      callback();
    }

    function sayBye() {
      console.log("Bye!");
    }

    greet("John", sayBye);   

    What will be printed?

üÖ∞Ô∏è output :  Hello John
              Bye!


5. function a(cb) {
      console.log("A");
      cb();
    }

    function b(cb) {
      console.log("B");
      cb();
    }

    function c() {
      console.log("C");
    }

    a(b(c)); 

    Will this work? What will happen?

üÖ∞Ô∏è B
    C
    A
    TypeError: cb is not a function

    Explanation :

    Step 1: Evaluate the inner call first ‚Üí b(c)
          cb = c
          Inside b:
            console.log("B") ‚Üí prints B
            cb() ‚Üí executes c()

    Step 2: Inside c()
            console.log("C") ‚Üí prints C
            c() returns undefined

    Step 3: Return value of b(c)
              b(c) returns undefined
            So the call becomes:
              a(undefined)

    Step 4: Now execute a(undefined)
          Inside a:
          console.log("A") ‚Üí prints A
          cb() ‚Üí but cb is undefined
          Calling undefined() causes:

          TypeError: cb is not a function

     ‚úÖ Imporving above code

        code 1 : 
        function a(cb) {
          console.log("A");
          cb(c);   // pass c into b
        }

        function b(cb) {
          console.log("B");
          cb();    // run c()
        }

        function c() {
          console.log("C");
        }

        a(b);

        output :  A
                  B
                  C

        code 2 : 
        function a(cb) {
            console.log("A");
            cb();
          }

          function b(cb) {
            console.log("B");
            cb();
          }

          function c() {
            console.log("C");
          }

          a(() => b(c));

          output :  A
                    B
                    C


6. function x(cb) {
      console.log("X");
      cb("test");
    }

    function y(value) {
      console.log("Y got:", value);
    }

    x(y);

    What is printed?

üÖ∞Ô∏è output : X
            Y got: test


7. What is ‚Äúcallback hell‚Äù? Why is it a problem?

üÖ∞Ô∏è    good and bad parts of callbacks in JavaScript.
        Good part of callbacks: essential for handling asynchronous operations in JavaScript by allowing code to execute later.
        bad parts of callbacks: callback hell(pyramid of doom) horizontal expansion of code, inversion of control

        Inversion of control: when callbacks are passed to other functions, developers lose control over the execution of the code,
        which can lead to issues like callbacks not being called or being called multiple times.

8. Why does this code crash?

        function first(cb) {
        cb();
      }

      first( second() );

      function second() {
        console.log("Second");
      }
     Explain what the fix is.

üÖ∞Ô∏è  Why it crashes?

      first( second() );
        second() is executed immediately, before first runs.
        second() prints "Second" and returns undefined.
        So JavaScript actually calls:

        first(undefined);
          Inside first:
          cb();  // cb is undefined ‚Üí NOT a function
          This causes:
          TypeError: cb is not a function

    The code crashes because second() runs immediately, returns undefined, and first tries to call undefined as a function.
    The fix is to pass the function reference instead: first(second).

       FIX: 
         function first(cb) {
            cb();
          }

          first( second );

          function second() {
            console.log("Second");
          }


9. What happens if a callback is not passed?

    function fetchData(cb) {
        console.log("Fetching...");
        cb();
      }

      fetchData();  // no callback provided

üÖ∞Ô∏è output : Fetching...
            TypeError: cb is not a function

    If a callback isn‚Äôt passed, the callback parameter becomes undefined, and calling cb() causes a TypeError.
    To avoid this, always validate the callback before calling it.

     ‚úÖ  Correct Defensive Fix
          function fetchData(cb) {
              console.log("Fetching...");

              if (typeof cb === "function") {
                cb();
              }
            }

          or 

          cb?.();


10. function step1(cb) {
        setTimeout(() => {
          console.log("Step 1");
          cb();
        }, 1000);
      }

      function step2(cb) {
        setTimeout(() => {
          console.log("Step 2");
          cb();
        }, 500);
      }

      function step3() {
        console.log("Step 3");
      }

      step1(() => step2(step3));

      Explain the exact order and timing of logs.

üÖ∞Ô∏è The exact order is:

      Step 1 ‚Üí at 1000ms
      Step 2 ‚Üí at 1500ms
      Step 3 ‚Üí immediately after Step 2 (also ~1500ms)

      but by the observation I see in logs step 1 executes after 1000ms after that step 2 executes from there onwards 500ms, 
      so If we see from the 0 ms we say that step 1 executes after 1000ms and step 2 executes after 1500ms

      Step 1 runs 1000 ms after the program starts.
      After Step 1 finishes, Step 2 starts its own timer of 500 ms.
      So Step 2 executes at 1000 + 500 = 1500 ms from the beginning
      Yes ‚Äî this understanding is correct.

    
11. Why is this wrong?

     getUser(function(result) {
          console.log(result.name);
        });

        function getUser(cb) {
          setTimeout(() => {
            cb({ name: "John" });
          }, 1000);
        }

        const cb = (x) => console.log("Got:", x);
        getUser(cb());

        Explain the bug and fix it.

üÖ∞Ô∏è  output : Got: undefined
              John
              TypeError: cb is not a function

    cb() runs immediately, so before anything else you see:
      Got: undefined       (at ~0ms)

    Because cb() returns undefined, getUser(cb()) becomes getUser(undefined).
    After 1000ms, the first correct getUser(...) call prints:
        John                 (at ~1000ms)

    Immediately after that, the incorrect getUser(undefined) tries to run cb({name:"John"}), but cb is undefined, so it throws:
    TypeError: cb is not a function   (at ~1000ms)

    ‚úÖ Final Correct Fix

      getUser(function(result) {
          console.log(result.name);
        });

        function getUser(cb) {
          setTimeout(() => {
            cb({ name: "John" });
          }, 1000);
        }

        const cb = (x) => console.log("Got:", x);
        getUser(cb);

        output : After 1000ms
                  John
                  Got: { name: 'John' }

        1. The program starts by calling:

            getUser(function(result) {
              console.log(result.name);
            });

            This schedules a setTimeout for 1000ms.
            No output yet ‚Äî the callback will run after 1 second.

        2. The getUser function is defined (hoisted), so it‚Äôs available before use.

        3. The arrow function cb is defined:
              const cb = (x) => console.log("Got:", x);
            This does nothing immediately; it just stores a function in cb.

        4. The program calls:
            getUser(cb);
            This schedules another 1000ms timer that will call cb({ name: "John" }).

        Timer 1 (from the first call):
            console.log(result.name);

        Timer 2 (from getUser(cb)):
              cb({ name: "John" });


12. What is the difference between: 
      a. callback that expects a value : cb(result);
      b. callback that passes function instead of value : cb(() => result);

      When do you use each?

üÖ∞Ô∏è   When to Use Each (Interview-Ready)
        ‚úÖ Use cb(result) when:
        The result is ready.
        You want to pass data immediately.
        No need for deferred/lazy execution.

        ‚úÖ Use cb(() => result) when:

        The caller should decide when to run the code.
        You want lazy evaluation.
        The value is expensive to compute.
        You want to pass logic/behavior instead of raw data.

      cb(result) gives the caller data immediately.
      cb(() => result) gives the caller a function so they can compute or use the data later.

      code snippet 1:

      function getNumber(cb) {
          const result = 42;
          cb(result); // pass the value NOW
        }

        getNumber(function (value) {
          console.log("Received:", value);
        });

         code snippet 2:

         function getNumber(cb) {
              const result = 42;
              cb(() => result); // pass a FUNCTION, NOT the value
            }

            getNumber(function (getValue) {
              console.log("Callback received a function, not the value");

              console.log("Now I decide when to get the value...");
              console.log("Received:", getValue()); // call the function here
            });

13. Write a function repeatNTimes that accepts:
      a callback,
      a number N,
      and runs the callback N times.

      repeatNTimes(() => console.log("Hi"), 3);

üÖ∞Ô∏è     function repeatNTimes(cb, N){
          for(let i = 0; i < N; i++){
            cb()
          }
      }

      repeatNTimes(() => console.log("Hi"), 3);

      output : Hi
               Hi
               Hi

14. Turn this into callback-based asynchronous flow:

      Wash vegetables ‚Üí Cut vegetables ‚Üí Cook food ‚Üí Serve food

      Each step should happen after a timeout with a callback.

üÖ∞Ô∏è  ‚úÖ version 1

        //  Wash vegetables ‚Üí Cut vegetables ‚Üí Cook food ‚Üí Serve food
 
              function washVegetables(cb){
                  setTimeout(()=>{
                      console.log("washed vegetable")
                      cb(cookFood)
                  },1000)
              }
              
              function cutVegaetable(cb){
                  setTimeout(()=>{
                      console.log("cut vegetable")
                      cb(serveFood)
                  }, 1000)
              }
              
              function cookFood(cb){
                  setTimeout(()=>{
                      console.log("cooked food")
                      cb()
                  }, 1000)
              }
              
              function serveFood(){
                  setTimeout(()=>{
                      console.log("served food")
                  }, 1000)
              }
              
              washVegetables(cutVegaetable)
 
    ‚úÖ version 2

              function washVegetables(cb) {
                  setTimeout(() => {
                    console.log("Washed vegetables");
                    cb();
                  }, 1000);
                }

                function cutVegetables(cb) {
                  setTimeout(() => {
                    console.log("Cut vegetables");
                    cb();
                  }, 1000);
                }

                function cookFood(cb) {
                  setTimeout(() => {
                    console.log("Cooked food");
                    cb();
                  }, 1000);
                }

                function serveFood() {
                  setTimeout(() => {
                    console.log("Served food");
                  }, 1000);
                }

                // Call them in sequence:
                washVegetables(() => 
                  cutVegetables(() => 
                    cookFood(() => 
                      serveFood()
                    )
                  )
                );


  ‚úÖ version 3

          function washVegetables(next) {
                setTimeout(() => {
                  console.log("Washed vegetables");
                  next(cookFood); // pass the next function to cutVegetables
                }, 1000);
              }

              function cutVegetables(next) {
                setTimeout(() => {
                  console.log("Cut vegetables");
                  next(serveFood); // pass cookFood a reference to serveFood
                }, 1000);
              }

              function cookFood(next) {
                setTimeout(() => {
                  console.log("Cooked food");
                  next();
                }, 1000);
              }

              function serveFood() {
                setTimeout(() => {
                  console.log("Served food");
                }, 1000);
              }

              // Start the chain:
              washVegetables(cutVegetables);


15. Why do modern JS developers prefer Promises and async/await over callbacks?

üÖ∞Ô∏è  Developers prefer Promises and async/await because they avoid callback hell, provide cleaner error handling, offer predictable flow,
        and make asynchronous code easier to read, write, and maintain.
---------------------------------------------------------------------------------------------------------------------------------------
ü§î Promise

1. What is a Promise in JavaScript, and why do we use it?

üÖ∞Ô∏è  Before promises, developers used callbacks to handle async operations,
      but this created an "inversion of control" problem where you blindly trust external code to call your callback.

      With promises, API returns a promise object that initially contains undefined data but 
      will eventually be filled with the result of the async operation.

      Instead of passing callbacks to functions, you attach callbacks to promise objects using .then(),
      which guarantees the callback will be called exactly once when data is available.

      Promises have three possible states: pending (initial state), fulfilled (successful completion), or rejected (failed operation).
            ‚úÖ resolve, success, fulfilled.
            ‚ùå reject, failure, rejected.

      A promise is defined as "an object representing eventual completion of an async operation."

      Promises solve the "callback hell" problem by allowing chaining with .then() methods, 
      transforming horizontal nested callbacks into a vertical, more readable chain.

      Key advantages of promises: they maintain control of your program flow, guarantee callbacks are called exactly once, 
      and provide a more readable way to handle asynchronous operations.

      Promise returns a Promise object
      .then() also returns a Promise object
      But the callback inside .then() returns the value, which becomes the resolution of the new Promise

        code snippet 1

      const p = Promise.resolve(5);
      const result = p.then(x => x + 1);
      console.log(result);     // Promise {<fulfilled>: 6}

      code snippet 2

      const p = Promise.resolve(5);
      const result = p.then(x => x + 1).then(v => console.log(v));


2. What are the three states of a Promise?

üÖ∞Ô∏è  1. Pending

      The initial state
      The promise is running its async operation
      Neither fulfilled nor rejected yet

      2. Fulfilled (Resolved)

      The async operation completed successfully
      The promise now has a value
      Calls the .then() handlers

      3. Rejected

      The async operation failed
      The promise now has a reason (error)
      Calls the .catch() handlers

3. What is the difference between: return Promise.resolve(5); and return 5; inside an async function?

üÖ∞Ô∏è Inside an async function, return 5 and return Promise.resolve(5) are equivalent ‚Äî both return a resolved Promise with value 5, 
    because async functions wrap return values in a Promise.

    Inside an async function,
      return 5 is automatically converted into a resolved Promise.
      So inside an async function:
      return 5
      becomes ‚Üí return Promise.resolve(5)
      return Promise.resolve(5)
      is explicitly returning the same thing.

      ‚úî Both produce a promise resolved with 5.

     code snippet 1:

      async function foo1(){
            return 5    
        }
      foo1().then(console.log)   // 5

      code snippet 2: 

      async function foo2(){
          return Promise.resolve(5)    
      }
      foo2().then(console.log)   // 5

      code snippet 3:

      return Promise.resolve(5) inside an async function
        Here you manually create a resolved Promise:

        async function foo() {
          return Promise.resolve(5);
        }

        Since it‚Äôs inside an async function, the returned Promise is wrapped, but JS automatically unwraps it (promise flattening).
        Result is the same.


4. What is logged and in what order?

    const p = new Promise((resolve, reject) => {
        console.log("A");                               // promise executor -> consider has a synchronous code
        resolve("B");                                    // promise executor -> consider has a synchronous code
      });

      p.then(val => console.log(val));                // promise handler -> consider has a asynchronous code
      console.log("C");                        // normal JS synchronous code

üÖ∞Ô∏è  1. The code inside new Promise(...) is the executor, which runs immediately and synchronously.
    2. The code inside .then(...) is a Promise handler, which runs asynchronously as a microtask after all synchronous code finishes.

      output : A
               C 
               B

5. What does it print?

    Promise.resolve(1)
      .then(x => x + 1)
      .then(x => {
        throw new Error("Oops");
      })
      .catch(err => 5)
      .then(x => console.log(x));

üÖ∞Ô∏è  5

      Why? (clear, short explanation)

      1. Promise.resolve(1)
            Resolves with 1.

      2. .then(x => x + 1)
            Receives 1, returns 2.

      3. .then(x => { throw new Error("Oops") })
            Throws an error ‚Üí Promise goes into rejected state.

      4. .catch(err => 5)
            Catches the error and returns 5 ‚Üí Promise is fulfilled with value 5.

      5. .then(x => console.log(x))
            Receives 5 and prints:

      Yes ‚Äî when an error occurs in a Promise chain, it bypasses the remaining .then() handlers and goes straight to the nearest .catch().

6. What prints first?

      new Promise((resolve) => {
        setTimeout(() => resolve("Done"), 2000);
      }).then(console.log);

      console.log("Hello");

üÖ∞Ô∏è  output : Hello
              After 2 second
              Done

7. Why does .then() return a new Promise?

üÖ∞Ô∏è 1. To allow chaining
        Every .then() creates and returns a new Promise, so you can write:
           p.then(...).then(...).then(...)
        If .then() didn‚Äôt return a new Promise, chaining would not work.

    2. To capture the result of the previous step
        Whatever you return inside .then() becomes the value of the new Promise it creates:
          Promise.resolve(1)
            .then(x => x + 1)   // returns 2 ‚Üí becomes new Promise value
    
    3. To handle errors cleanly

    .then() returns a new Promise so you can chain asynchronous steps, pass transformed values to the next step, and propagate errors through the chain.

      code snippet 1 : 

      const p = new Promise((resolve, reject)=>{
            resolve(5)
        })

        p.then((x)=> console.log(x)).then((y) => console.log(y + 2))

       code snippet 2 : 

       p.then((x)=> {
          console.log(x);
          return x;   // return the value for the next .then
        })
        .then((y) => console.log(y + 2));


8. What is wrong with this code?

    function getData() {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve("data");
          }, 1000);
        });
      }

      const result = getData();
      console.log(result); // What prints? Why?    // Promise { <pending> }

üÖ∞Ô∏è The mistake is logging the Promise instead of its resolved value ‚Äî since Promises are asynchronous, you must use .then() or await to access "data".

    function getData() {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve("data");
          }, 1000);
        });
      }

      const result = getData().then(data => console.log(data));

9. What numbers print?

      Promise.resolve(10)
        .then(x => {
          console.log(x);
          return x * 2;
        })
        .then(x => {
          console.log(x);
          return Promise.resolve(x * 2);
        })
        .then(console.log);
      
üÖ∞Ô∏è 10
    20
    40


10. What prints?

      Promise.reject("Error")
        .catch((msg) => {
          console.log("Caught:", msg);
          return "Recovered";
        })
        .then((msg) => {
          console.log("Then:", msg);
        });

üÖ∞Ô∏è A .catch() that returns a value converts the Promise back into a fulfilled state, so the next .then() runs normally. .catch() does not stop the chain.

      output : Caught: Error
                Then: Recovered

11. What happens if you forget to return in a .then() chain?

üÖ∞Ô∏è If you forget to return inside a .then(), the next .then() receives undefined, which breaks your Promise chain.

      Promise.resolve(5)
        .then(x => {
          console.log(x);  // prints 5
          // forgot to return x + 1
        })
        .then(y => {
          console.log(y);  // prints undefined
        });


12. Why does this code NOT catch the error?

        try {
          Promise.reject("Fail");
        } catch (err) {
          console.log("Caught:", err);
        }

üÖ∞Ô∏è try/catch only catches synchronous errors. Promise rejections are asynchronous, 
    so you must use .catch() or await inside an async function for try/catch to work.

      ‚≠ê Correct ways to catch it

        code snippet 1:

        Promise.reject("Fail")
          .catch(err => console.log("Caught:", err));

        code snippet 2: 

        async function run() {
          try {
            await Promise.reject("Fail");
          } catch (err) {
            console.log("Caught:", err);
          }
        }

        run();
  
13.  What prints? Why is it not 1?

        async function test() {
            return 1;
          }

          console.log(test());

üÖ∞Ô∏è output : Promise { <fulfilled>: 1 }
    Because async functions ALWAYS return a Promise, no matter what you return inside them.

14.  What is Promise.all, and what happens if one promise rejects?
üÖ∞Ô∏è Alreadyy done

15. Write a function wait(ms) that returns a Promise which resolves after ms milliseconds.

      wait(1000).then(() => console.log("1 second passed"));

üÖ∞Ô∏è       function wait(ms){
       
              return new Promise((resolve, reject)=> {
                  resolve("promise resolved")
                    })
                setTimeout(resolve, ms)
            }
      
         wait(1000).then(() => console.log("1 second passed"));    

16. Convert this callback-based function into a Promise: 

      function fetchUser(callback) {
        setTimeout(() => {
          callback({ name: "John" });
        }, 1000);
      }

üÖ∞Ô∏è   function fetchUser() {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve({ name: "John" });
          }, 1000);
        });
      }

      fetchUser().then(user => console.log(user));        // { name: "John" }


17. What is the difference between:

        Promise.all
        Promise.allSettled
        Promise.race
        Promise.any

        Explain real use cases.
üÖ∞Ô∏è Alreadyy done

18. In how many ways promise can we create ? 

üÖ∞Ô∏è  1. Using the new Promise constructor (most common)

        const p = new Promise((resolve, reject) => {
            resolve(10);
          });

     2. Using Promise.resolve(), const p = Promise.resolve(42);
        Using Promise.reject(), const p = Promise.reject("Error");

      3. Using async functions (automatically returns a Promise) 
             async function foo() {
                return 5; // becomes Promise.resolve(5)
              }

      4. Using Promise utility methods
          These also create Promises internally:

          Promise.all([...])
          Promise.allSettled([...])
          Promise.race([...])
          Promise.any([...])

    ‚≠ê Code Snippet: Compulsory Things to Remember When Creating a Promise

          function fetchData() {

              // 1. Always RETURN the Promise so the caller can use .then() or await
              return new Promise((resolve, reject) => {

                // 2. Promise executor runs IMMEDIATELY and SYNCHRONOUSLY
                console.log("Executor started");

                // Simulate async task
                setTimeout(() => {

                  try {
                    // 3. You MUST call either resolve() or reject()
                    const data = { name: "John" };

                    // If everything is OK ‚Üí resolve once
                    resolve(data);

                    // ‚ùó Never call resolve() or reject() more than once
                    // resolve("won't run");  // WRONG

                  } catch (error) {

                    // 4. If something fails ‚Üí reject the Promise
                    reject(error);
                  }

                }, 1000);

              });
            }


            // USING THE PROMISE
            fetchData()
              .then((data) => {
                console.log("Resolved with:", data);
              })
              .catch((err) => {
                console.log("Rejected with:", err);
              });

19. Prmoise chain

üÖ∞Ô∏è function step1(){
      return new Promise((resolve, reject) => {
        resolve("data 1");
      });
    }

    function step2(a){
      return new Promise((resolve, reject) => {
        resolve("data 2," + a);
      });
    }

    function step3(b){
      return new Promise((resolve, reject) => {
        resolve("data 3,"+ b);
      });
    }

    // Proper chaining
    step1()
      .then(x => {
        console.log(x);        // "data 1"
        return step2(x);        // <-- return the Promise from step2
      })
      .then(y => {
        console.log(y);        // "data 2"
        return step3(y);        // <-- return the Promise from step3
      })
      .then(z => {
        console.log(z);        // "data 3"
      })
      .catch(err => {
        console.error("Error:", err);
      });

20. JavaScript Promise Corner Cases Asked in Interviews

üÖ∞Ô∏è 1. Microtask Queue vs Macrotask Queue

          .then() runs in microtask queue

          setTimeout runs in macrotask queue

          Microtasks run before macrotasks

          Example:
          console.log("A");
          Promise.resolve().then(() => console.log("B"));
          setTimeout(() => console.log("C"), 0);
          console.log("D");

          Output:
          A
          D
          B
          C

    2. Missing return inside .then() chain
          
          Example:
          Promise.resolve("X")
          .then(x => {
          console.log(x);
          step2(); // not returned
          })
          .then(y => console.log("Y:", y));

          Output:
          Y: undefined

    3. Promise inside another Promise

          Example:
          Promise.resolve(1)
          .then(() => Promise.resolve(2))
          .then(v => console.log(v));

          Output:
          2

    4. Error handling corner cases

        A: Throwing inside .then()
        Promise.resolve()
        .then(() => { throw "ERR"; })
        .catch(e => console.log("Caught:", e));

        Output:
        Caught: ERR

        B: Returning a rejected Promise
        Promise.resolve()
        .then(() => Promise.reject("Oops"))
        .catch(console.log);

        Output:
        Oops

        C: .catch() does not stop the chain
        Promise.reject("A")
        .catch(() => "Recovered")
        .then(v => console.log(v));

        Output:
        Recovered

    5. Promise constructor trick
          new Promise((resolve, reject) => {
          throw "ERR";
          });

          This becomes a rejected Promise; it does NOT crash the program.

    6. Double resolve or resolve-after-reject
          Only the first call counts.

          new Promise((resolve, reject) => {
          resolve("A");
          reject("B");
          resolve("C");
          }).then(console.log, console.error);

          Output:
          A

    7. Promise.all failure behavior
        Promise.all rejects fast ‚Äî if ANY Promise rejects, the whole thing rejects.

        Promise.all([
        Promise.resolve("A"),
        Promise.reject("B"),
        Promise.resolve("C")
        ]).catch(console.log);

        Output:
        B
    
    8. Promise.race behavior
        Whichever Promise resolves OR rejects first wins.

    9. async/await error propagation

          async function test() {
          try {
          await Promise.reject("Err");
          } catch (e) {
          console.log("Caught:", e);
          }
          }

    10. async functions always return a Promise

          async function x() { return 10; }
          x().then(console.log); // prints 10

    11. await on non-promise

            await 5;
            Equivalent to:
            Promise.resolve(5)
        
    12. console.log(1);
        setTimeout(() => console.log(2), 0);

        Promise.resolve().then(() => {
        console.log(3);
        setTimeout(() => console.log(4), 0);
        });

        Promise.resolve().then(() => console.log(5));
        console.log(6);

        Output:
        1
        6
        3
        5
        2
        4

--------------------------------------------------------------------------------------------------------------------------------
ü§î async/await 

1. What is async/await, and why was it introduced in JavaScript?

üÖ∞Ô∏è  Async/await is ES8 syntax that makes asynchronous JavaScript look synchronous.
    It was introduced to solve callback hell, reduce Promise chaining complexity, improve error handling with try/catch, 
    and make async code easier to read and maintain. It is built on top of Promises.

2. What does the async keyword do to a function?

üÖ∞Ô∏è 1. It automatically makes the function return a Promise
    2. It allows you to use await inside the function
    3. It wraps errors inside rejected promises

3. What happens if you await a non-Promise value?

üÖ∞Ô∏è If you await a non-Promise value, JavaScript automatically wraps it in Promise.resolve() and await returns 
    that value immediately without any delay or error.

4. Why must await only be used inside an async function?

üÖ∞Ô∏è await must be used inside an async function because async functions create a special asynchronous context 
    that allows execution to pause without blocking the main thread. Normal functions cannot be paused, so JavaScript disallows await in them.

5. What gets printed, and why?

    async function test() {
      return "Hello";
    }

    console.log(test());

üÖ∞Ô∏è  output : Promise { 'Hello' }  

    async function test() {
          return "Hello";
        }

        console.log(test().then((x)=> console.log(x)));

    output : Promise { <pending> }
              Hello


6. What is the exact output order?

      async function f() {
        console.log(1);
        await Promise.resolve();
        console.log(2);
      }

      console.log(3);
      f();
      console.log(4);

üÖ∞Ô∏è 3
    1
    4
    2


7. What logs first?

    async function getData() {
      await new Promise(res => setTimeout(res, 1000));
      return 10;
    }

    getData().then(console.log);
    console.log("Done");

üÖ∞Ô∏è Done
    10

8. How do you handle errors in async/await?
    Show both try/catch and .catch() approaches.

üÖ∞Ô∏è Error handling with try/catch (most common way) Inside async

        async function fetchData() {
          try {
            const response = await fetch("/api/data");
            const data = await response.json();
            return data;
          } catch (err) {
            console.error("Error:", err);
          }
        }
     
     Error handling with .catch() outside the async function

     async function fetchData() {
        const response = await fetch("/api/data");
        return response.json();
      }

      fetchData()
        .then(data => console.log(data))
        .catch(err => console.error("Error:", err));

9.  Will ‚ÄúAfter‚Äù print? Why?

      async function test() {
          throw new Error("Oops");
        }

        test();
        console.log("After");

üÖ∞Ô∏è  output : After
              Error

        function testSync() {
            throw new Error("Oops");
          }

          testSync();            // throws here
          console.log("After"); // never reached

      output : Uncaught Error: Oops
              // "After" is NOT printed because the exception terminated the synchronous flow

 
10. Why doesn't this catch the error?

      try {
        async function run() {
          throw new Error("Fail");
        }
        run();
      } catch (e) {
        console.log("Caught!");
      }

üÖ∞Ô∏è try/catch only catches synchronous errors.
    Because async functions don‚Äôt throw errors synchronously.
    The throw inside an async function turns into a rejected Promise, which happens asynchronously, so the outer try/catch cannot catch it.
    You must either await the Promise inside the try block or use .catch() on the Promise.
  
11. What logs and in what order?

      async function a() {
        console.log("A1");
        await b();
        console.log("A2");
      }

      async function b() {
        console.log("B1");
        return "B done";
      }

      a();

üÖ∞Ô∏è  A1
     B1
     A2

12.  What is the difference between:

      ‚úîÔ∏è awaiting multiple Promises sequentially
      ‚úîÔ∏è awaiting them in parallel with Promise.all

üÖ∞Ô∏è   Sequential awaits run tasks one by one, while Promise.all runs 
      them in parallel and waits for all to finish. Use sequential when 
      tasks depend on each other; use Promise.all when they don‚Äôt.

13. What prints and after how long?

      async function slow() {
        await new Promise(res => setTimeout(res, 2000));
        return "slow";
      }

      async function fast() {
        await new Promise(res => setTimeout(res, 500));
        return "fast";
      }

      async function run() {
        const s = slow();
        const f = fast();
        console.log(await f, await s);
         //  console.log(await f);
         //  console.log(await s)
      }

      run();


14. Why is .forEach not async-await friendly?

      [1,2,3].forEach(async (num) => {
        await wait(1000);
        console.log(num);
      });


15. Rewrite this code using async/await:

      fetchData()
        .then(processData)
        .then(saveData)
        .catch(handleError);

16. Why is await inside a loop often a performance issue?
      What is the better alternative? 

17.  What will be the output?

    async function test() {
        console.log("Start");

        const promise = new Promise((res) => {
          console.log("Inside Promise");
          res("Done");
        });

        console.log(await promise);
        console.log("End");
      }

      test();

üÖ∞Ô∏è  Start
      Inside Promise
      Done
      End

18. Why should you almost always return inside a try block when using async/await?

üÖ∞Ô∏è You should return inside a try block when using async/await because if you don‚Äôt, 
   the function will keep running after the try/catch finishes, even when an error happens. This can lead to unintended code execution, wrong return values, 
   and swallowed errors. Returning inside the try ensures a clean, predictable control flow for both success and failure cases.

19. What happens if you forget await before a Promise?

üÖ∞Ô∏è If you forget await before a Promise, the async function won‚Äôt pause. You get the Promise itself instead of the resolved value, 
   errors won‚Äôt be caught by try/catch, the code runs out of order, and you often return Promises you didn‚Äôt mean to. 
   This is one of the most common async/await bugs.

20. Create a sleep(ms) function using async/await:

      await sleep(2000);
      console.log("2 seconds passed");
--------------------------------------------------------------------------------------------------------------------------------
ü§î Currying function

1. What is currying in JavaScript? Explain in simple words with an example.

2. What is the main difference between currying and partial application?

3. Why is currying useful in functional programming?

4. What will this code print?

      function add(a) {
        return function (b) {
          return a + b;
        };
      }

      console.log(add(5)(3));


5. Write a simple curry function that converts: 
    
    function add(a, b, c) { return a + b + c; }

    into 

    curry(add)(1)(2)(3) // 6


6. What is the output?
    
    function multiply(a) {
        return function(b) {
          return function(c) {
            console.log(a * b * c);
          };
        };
      }

      multiply(2)(3)(4);


7.  Explain how currying helps in reusing functions.

      function log(type) {
          return function(message) {
            console.log(`[${type}] : ${message}`);
          };
        }


8. Convert this normal function into a curried version:

      function discount(price, percentage) {
          return price * (percentage / 100);
        }

    Expected output:

      const tenPercent = curriedDiscount(10);
      console.log(tenPercent(500)); // 50


9. What is the output?

      function sum(a) {
        return function(b) {
          if (b !== undefined) return sum(a + b);
          return a;
        };
      }

      console.log(sum(1)(2)(3)());


10. Why does currying help with functions that accept many arguments?

11. Why does this code fail?

      function add(a, b) {
          return a + b;
        }

        const curriedAdd = add(5);
        console.log(curriedAdd(10));

        Explain what the fix is.


12. Create a generic curry function that works for any number of arguments:

        function sum(a, b, c, d) { return a + b + c + d; }

        const curried = curry(sum);
        console.log(curried(1)(2)(3)(4)); // 10


13. What will the following code produce?

        function evaluate(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                console.log(a + b + c + d);
              };
            };
          };
        }

        evaluate(1)(2)(3)(4);


14. How does currying help with event handling?

    const handleEvent = (type) => (msg) => console.log(type, msg);

    document.addEventListener("click", () => handleEvent("CLICK")("Button pressed"));

15. Rewrite this function to support both styles:

    sum(1,2,3);   // 6  
    sum(1)(2)(3); // 6
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î Debouncing

1. What is debouncing in JavaScript, and why do we use it? Explain using a real-world example (like typing in a search bar).

2. What is the difference between debouncing and throttling? Give one use case for each.

3. Write a basic debounce function that takes a callback and delay:

      function debounce(fn, delay) { /* your code */ }
 
        Explain how it works internally.

4. You have an input box and want to call an API only after the user stops typing for 500ms.
      How will you use debounce here?
      Write a small code snippet showing usage.

5. What happens in this scenario?

      const fn = () => console.log("API Call");
        const debounced = debounce(fn, 1000);

        debounced();
        debounced();
        debounced();

    How many times does "API Call" print, and why?


6. Why must we use clearTimeout inside a debounce function?
      Explain what happens if we don't.

7. Modify debounce so it supports an option:

      immediate: true

      Meaning:
      Run the function immediately at the first call, and then ignore calls until after the delay.

      Describe how you‚Äôd add this feature.

8. Why is this debounce implementation incorrect?

      function debounce(fn, delay) {
          let timer;
          return function() {
            setTimeout(() => {
              fn();
            }, delay);
          };
        }

      Describe the specific bug and how to fix it.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î Throttling

1. What is throttling in JavaScript, and why do we use it?
Explain using a real-world example (like scroll events or window resize).

2. Write a basic throttle function that ensures a callback runs at most once every delay milliseconds:

      function throttle(fn, delay) { /* your code */ }

      Explain the internal mechanism.

3. You want to run a function while a user scrolls, but not on every pixel movement ‚Äî only once every 200ms.
      Show how you would use throttle in this situation.

4.  const fn = () => console.log("Scroll event");
      const throttled = throttle(fn, 1000);

      throttled();
      throttled();
      throttled();

      How many times does "Scroll event" print and why?


5. Types of Throttling

Explain the difference between:

Leading throttle
Trailing throttle

Which one fires the callback at the start, and which one at the end of the delay window?

6. Modify your throttle function so it supports both options:

      leading: true,
      trailing: false

      Explain how you would handle these scenarios.


7. Why is the following throttle implementation incorrect?

        function throttle(fn, delay) {
          let timer;
          return function() {
            if (!timer) {
              setTimeout(() => {
                fn();
              }, delay);
            }
          };
        }

    Describe the exact bug and how to fix it.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î Event Bubbling

1. What is event bubbling in JavaScript?
Explain how an event moves through the DOM when a user clicks on a nested element.

2. Given the HTML:

      <div id="parent">
        <button id="child">Click me</button>
      </div>

    And JavaScript:

    document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked");
      });

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked");
      });

      If you click the button,
      what is the order of console logs and why?


3.   How does event.stopPropagation() affect event bubbling?
      Write a code snippet showing how to prevent the parent from receiving the event when the child is clicked.

4.   Why is event bubbling important for event delegation?
     Explain with an example where you handle clicks on multiple list items using a single event listener.

5.   Why does this code log both messages even after trying to stop bubbling?

      parent.addEventListener("click", () => console.log("Parent"));
        child.addEventListener("click", (e) => {
          console.log("Child");
          e.stopImmediatePropagation();
        });

        Explain what mistake was made and how to correctly prevent the parent's event from firing.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î Event capturing/trickling

1. What is event capturing in JavaScript?
    Explain how events travel during the capturing phase before they bubble back up.

2.  Given the HTML:

      <div id="outer">
        <div id="middle">
          <button id="inner">Click</button>
        </div>
      </div>

    And JavaScript:

    outer.addEventListener("click", () => console.log("Outer"), true);
    middle.addEventListener("click", () => console.log("Middle"));
    inner.addEventListener("click", () => console.log("Inner"));

    If you click the button,
    what is the exact log order and why?

    (Hint: one uses capturing, others default to bubbling)


3.  Explain the difference between:

    element.addEventListener("click", handler, true);
      vs
    element.addEventListener("click", handler, false);

    Give one scenario where capturing is actually useful.

4.  Does event.stopPropagation() stop the capturing phase, bubbling phase, or both?
      Explain with a small code example.

5.  Why does this code still log "Parent" even though the child listener is in the capturing phase?

      parent.addEventListener("click", () => console.log("Parent"), true);

      child.addEventListener("click", (e) => {
        console.log("Child");
        e.stopPropagation();
      }, true);

      Explain what is happening, and how to make sure only the child logs.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î Event Delegation

1.  What is event delegation in JavaScript, and why do we use it?
      Explain using a real-world example (such as clicking multiple list items with one event listener).

2.  Given this HTML:

      <ul id="menu">
        <li class="item">Home</li>
        <li class="item">About</li>
        <li class="item">Contact</li>
      </ul>

    Write JavaScript code using event delegation so that clicking any <li> logs its text content.

3.  What is the difference between event.target and event.currentTarget in event delegation?
      Explain with an example of a nested HTML structure.

4.  Why is event delegation better for performance when dealing with a large number of dynamically created DOM elements?
    Give a practical scenario where delegation is the only scalable option.

5.  Why does the following event delegation fail to log anything?

      document.getElementById("list").addEventListener("click", (e) => {
          if (e.target === "li") {
            console.log("Clicked:", e.target.textContent);
          }
        });

      Identify the bug and explain how to fix it.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ü§î Event propogation

1.  What is event propagation in JavaScript?
    Explain the three phases of event propagation:

    Capturing (trickling)
    Target
    Bubbling

    Provide a simple example to demonstrate the full flow.

2. Given this HTML:

    <div id="grandparent">
      <div id="parent">
        <button id="child">Click</button>
      </div>
    </div>

    And JavaScript:

    grandparent.addEventListener("click", () => console.log("Grandparent Capture"), true);
    parent.addEventListener("click", () => console.log("Parent Bubble"));
    child.addEventListener("click", () => console.log("Child Target"));

    If the user clicks the button,
    what is the exact log order and why?


3.  What is the difference between stopPropagation() and stopImmediatePropagation()?

    Give an example where both listeners are on the same element, and only one method prevents the second from firing.

4.  If an event listener calls event.stopPropagation() inside the capturing phase, does it prevent:

    only bubbling?
    only capturing?
    or both?

    Explain with a code snippet.

5.  Why does this code still trigger the parent click event even though we are trying to stop propagation?

    parent.addEventListener("click", () => console.log("Parent clicked"));
    child.addEventListener("click", (e) => {
      console.log("Child clicked");
      e.stopPropagation();
    });
    child.innerHTML = "<span>Click me</span>";

    Clicking the <span> logs:

    Child clicked
    Parent clicked

    Explain what is happening and how to correctly stop propagation.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------







ðŸ¤” setTimout

1. What does setTimeout(fn, 0) actually mean? Does it execute fn immediately?

2. Can setTimeout guarantee exact timing of execution (e.g., exactly after 1000 ms)? Why or why not?

3. What happens if you pass a string instead of a function to setTimeout?

4. What does setTimeout return? How can you use it to cancel a scheduled function?  
=> It returns timerID (browser env), Returns a Timeout object (nodJS env)
    cancel a scheduled function through clearTimeout()

5. console.log(1);
setTimeout(() => console.log(2), 0);
console.log(3); 
Whatâ€™s the output, and why?


6. for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
What will this log, and how would you fix it to print 0, 1, 2?


7. let count = 0;
const timer = setTimeout(() => {
  count++;
  console.log('Timer executed');
}, 1000);
clearTimeout(timer);
console.log(count);
Whatâ€™s printed? Why?


8. setTimeout(() => console.log('Timeout 1'), 0);
Promise.resolve().then(() => console.log('Promise'));
console.log('Sync');
Explain the exact order of logs.


9. setTimeout(() => console.log('A'), 100);
setTimeout(() => console.log('B'), 50);
Will 'B' always log before 'A'?


10.How does JavaScript handle nested setTimeout calls for simulating intervals (e.g., recursive setTimeout vs. setInterval)?
Whatâ€™s the advantage of recursive setTimeout?


11. let start = Date.now();
setTimeout(() => {
  console.log('Delay:', Date.now() - start);
}, 0);
while (Date.now() - start < 2000) {}
What output do you expect? Why is the delay not 0?


12. setTimeout(() => console.log('Timeout'), 0);
process.nextTick(() => console.log('Next Tick'));
Promise.resolve().then(() => console.log('Promise'));
Whatâ€™s the output order? Why does Node behave this way?


13. How would you create your own version of setTimeout using setInterval?


14.let id = setTimeout(() => console.log('Run'), 1000);
id = setTimeout(() => console.log('Override'), 500);
clearTimeout(id);
Will anything print?
--------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” setTInterval

1. What does setInterval do, and how is it different from setTimeout?

2. Does setInterval(fn, 1000) guarantee that fn executes every exactly 1000ms? Why or why not? 
=>   console.log("start")

    setInterval(()=>{
    console.log("setInterval")
    }, 1000)

    let blockFor = Date.now() + 3000
    while(Date.now() < blockFor){}

    console.log("end")


     console.log("start")

    setInterval(()=>{

      let blockFor = Date.now() + 3000
    while(Date.now() < blockFor){}

    console.log("setInterval")
    }, 1000)
      console.log("end")
    

3. What does setInterval return, and how do you stop it?

4. What happens if the callback inside setInterval takes longer than the interval delay? (through blocking single thread & Callback Takes Longer Than Interval)
=> Timer drift
Time drift happens when the actual interval between executions of the callback function is longer than the specified interval time. This usually occurs when the main thread is blocked or the callback function takes longer to execute than expected. In such cases, the next invocation of the callback is delayed, and it can lead to the overall "drifting" of the scheduled times.


5. let i = 0;
const id = setInterval(() => {
  console.log(i++);
  if (i === 3) clearInterval(id);
}, 100);
What will be logged?


6. setInterval(() => console.log('A'), 0);
console.log('B');
What prints first? Why?


7. let x = 1;
setInterval(() => {
  x++;
  console.log(x);
}, 100);

setTimeout(() => {
  console.log("Timeout:", x);
}, 350);
What is printed by the timeout?


8. Why can setInterval sometimes â€œpile upâ€ callbacks?

9. let start = Date.now();

setInterval(() => {
  console.log("Interval fired at:", Date.now() - start);
}, 100);

while (Date.now() - start < 350) {}  // 350ms blocking
What do you expect the console output to look like?


10. Why is recursive setTimeout often considered better than setInterval?

11. let count = 0;
const id = setInterval(() => {
  console.log(count);
  count++;
  if (count === 1) clearInterval(id);
}, 100);
How many logs do we see?


12. setInterval(async () => {
  await new Promise(res => setTimeout(res, 200));
  console.log("Done");
}, 100);
Will this print every 100ms? What happens?


13. Does clearing an interval inside its own callback stop future executions immediately or after the current callback finishes?
=> Clearing an interval inside its own callback does not stop the current callback because itâ€™s already running on the call stack.
It only prevents the interval from scheduling future executions.


14. Why might this interval never run in a Node.js server?

while (true) {
  // accidental infinite loop
}

setInterval(() => console.log("Ping"), 1000);

15. How would you implement your own version of setInterval using recursive setTimeout?
---------------------------------------------------------------------------------------------------------------------------------------

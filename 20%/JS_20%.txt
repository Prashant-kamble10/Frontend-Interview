ðŸ¤” setTimout

1. What does setTimeout(fn, 0) actually mean? Does it execute fn immediately?

2. Can setTimeout guarantee exact timing of execution (e.g., exactly after 1000 ms)? Why or why not?

3. What happens if you pass a string instead of a function to setTimeout?

4. What does setTimeout return? How can you use it to cancel a scheduled function?  
=> It returns timerID (browser env), Returns a Timeout object (nodJS env)
    cancel a scheduled function through clearTimeout()

5. console.log(1);
setTimeout(() => console.log(2), 0);
console.log(3); 
Whatâ€™s the output, and why?


6. for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
What will this log, and how would you fix it to print 0, 1, 2?


7. let count = 0;
const timer = setTimeout(() => {
  count++;
  console.log('Timer executed');
}, 1000);
clearTimeout(timer);
console.log(count);
Whatâ€™s printed? Why?


8. setTimeout(() => console.log('Timeout 1'), 0);
Promise.resolve().then(() => console.log('Promise'));
console.log('Sync');
Explain the exact order of logs.


9. setTimeout(() => console.log('A'), 100);
setTimeout(() => console.log('B'), 50);
Will 'B' always log before 'A'?


10.How does JavaScript handle nested setTimeout calls for simulating intervals (e.g., recursive setTimeout vs. setInterval)?
Whatâ€™s the advantage of recursive setTimeout?


11. let start = Date.now();
setTimeout(() => {
  console.log('Delay:', Date.now() - start);
}, 0);
while (Date.now() - start < 2000) {}
What output do you expect? Why is the delay not 0?


12. setTimeout(() => console.log('Timeout'), 0);
process.nextTick(() => console.log('Next Tick'));
Promise.resolve().then(() => console.log('Promise'));
Whatâ€™s the output order? Why does Node behave this way?


13. How would you create your own version of setTimeout using setInterval?


14.let id = setTimeout(() => console.log('Run'), 1000);
id = setTimeout(() => console.log('Override'), 500);
clearTimeout(id);
Will anything print?
--------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” setTInterval

1. What does setInterval do, and how is it different from setTimeout?

2. Does setInterval(fn, 1000) guarantee that fn executes every exactly 1000ms? Why or why not? 
=>   console.log("start")

    setInterval(()=>{
    console.log("setInterval")
    }, 1000)

    let blockFor = Date.now() + 3000
    while(Date.now() < blockFor){}

    console.log("end")


     console.log("start")

    setInterval(()=>{

      let blockFor = Date.now() + 3000
    while(Date.now() < blockFor){}

    console.log("setInterval")
    }, 1000)
      console.log("end")
    

3. What does setInterval return, and how do you stop it?

4. What happens if the callback inside setInterval takes longer than the interval delay? (through blocking single thread & Callback Takes Longer Than Interval)
=> Timer drift
Time drift happens when the actual interval between executions of the callback function is longer than the specified interval time. This usually occurs when the main thread is blocked or the callback function takes longer to execute than expected. In such cases, the next invocation of the callback is delayed, and it can lead to the overall "drifting" of the scheduled times.


5. let i = 0;
const id = setInterval(() => {
  console.log(i++);
  if (i === 3) clearInterval(id);
}, 100);
What will be logged?


6. setInterval(() => console.log('A'), 0);
console.log('B');
What prints first? Why?


7. let x = 1;
setInterval(() => {
  x++;
  console.log(x);
}, 100);

setTimeout(() => {
  console.log("Timeout:", x);
}, 350);
What is printed by the timeout?


8. Why can setInterval sometimes â€œpile upâ€ callbacks?

9. let start = Date.now();

setInterval(() => {
  console.log("Interval fired at:", Date.now() - start);
}, 100);

while (Date.now() - start < 350) {}  // 350ms blocking
What do you expect the console output to look like?


10. Why is recursive setTimeout often considered better than setInterval?

11. let count = 0;
const id = setInterval(() => {
  console.log(count);
  count++;
  if (count === 1) clearInterval(id);
}, 100);
How many logs do we see?


12. setInterval(async () => {
  await new Promise(res => setTimeout(res, 200));
  console.log("Done");
}, 100);
Will this print every 100ms? What happens?


13. Does clearing an interval inside its own callback stop future executions immediately or after the current callback finishes?
=> Clearing an interval inside its own callback does not stop the current callback because itâ€™s already running on the call stack.
It only prevents the interval from scheduling future executions.


14. Why might this interval never run in a Node.js server?

while (true) {
  // accidental infinite loop
}

setInterval(() => console.log("Ping"), 1000);

15. How would you implement your own version of setInterval using recursive setTimeout?
---------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” callbacks

1. What is a callback function in JavaScript, and why do we use it?

2. What is the difference between: doSomething(callback); and  doSomething(callback());

3. Why are callbacks important in asynchronous programming?

4. function greet(name, callback) {
      console.log("Hello", name);
      callback();
    }

    function sayBye() {
      console.log("Bye!");
    }

    greet("John", sayBye);   

    What will be printed?


5. function a(cb) {
      console.log("A");
      cb();
    }

    function b(cb) {
      console.log("B");
      cb();
    }

    function c() {
      console.log("C");
    }

    a(b(c));

    Will this work? What will happen?


6. function x(cb) {
      console.log("X");
      cb("test");
    }

    function y(value) {
      console.log("Y got:", value);
    }

    x(y);

    What is printed?


7. What is â€œcallback hellâ€? Why is it a problem?

8. Why does this code crash?

        function first(cb) {
        cb();
      }

      first( second() );

      function second() {
        console.log("Second");
      }
     Explain what the fix is.


9. What happens if a callback is not passed?

    function fetchData(cb) {
        console.log("Fetching...");
        cb();
      }

      fetchData();  // no callback provided


10. function step1(cb) {
        setTimeout(() => {
          console.log("Step 1");
          cb();
        }, 1000);
      }

      function step2(cb) {
        setTimeout(() => {
          console.log("Step 2");
          cb();
        }, 500);
      }

      function step3() {
        console.log("Step 3");
      }

      step1(() => step2(step3));

      Explain the exact order and timing of logs.

    
11. Why is this wrong?

     getUser(function(result) {
          console.log(result.name);
        });

        function getUser(cb) {
          setTimeout(() => {
            cb({ name: "John" });
          }, 1000);
        }

        const cb = (x) => console.log("Got:", x);
        getUser(cb());

        Explain the bug and fix it.


12. What is the difference between: 
      a. callback that expects a value : cb(result);
      b. callback that passes function instead of value : cb(() => result);

      When do you use each?

13. Write a function repeatNTimes that accepts:
      a callback,
      a number N,
      and runs the callback N times.

      repeatNTimes(() => console.log("Hi"), 3);

14. Turn this into callback-based asynchronous flow:

      Wash vegetables â†’ Cut vegetables â†’ Cook food â†’ Serve food

      Each step should happen after a timeout with a callback.

15. Why do modern JS developers prefer Promises and async/await over callbacks?
---------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Promise

1. What is a Promise in JavaScript, and why do we use it?

2. What are the three states of a Promise?

3. What is the difference between: return Promise.resolve(5); and return 5; inside an async function?

4. What is logged and in what order?

    const p = new Promise((resolve, reject) => {
        console.log("A");
        resolve("B");
      });

      p.then(val => console.log(val));
      console.log("C");


5. What does it print?

    Promise.resolve(1)
      .then(x => x + 1)
      .then(x => {
        throw new Error("Oops");
      })
      .catch(err => 5)
      .then(x => console.log(x));


6. What prints first?

      new Promise((resolve) => {
        setTimeout(() => resolve("Done"), 2000);
      }).then(console.log);

      console.log("Hello");

7. Why does .then() return a new Promise?

8. What is wrong with this code?

    function getData() {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve("data");
          }, 1000);
        });
      }

      const result = getData();
      console.log(result); // What prints? Why?


9. What numbers print?

      Promise.resolve(10)
        .then(x => {
          console.log(x);
          return x * 2;
        })
        .then(x => {
          console.log(x);
          return Promise.resolve(x * 2);
        })
        .then(console.log);


10. What prints?

      Promise.reject("Error")
        .catch((msg) => {
          console.log("Caught:", msg);
          return "Recovered";
        })
        .then((msg) => {
          console.log("Then:", msg);
        });

11. What happens if you forget to return in a .then() chain?

12. Why does this code NOT catch the error?

        try {
          Promise.reject("Fail");
        } catch (err) {
          console.log("Caught:", err);
        }

  
13.  What prints? Why is it not 1?

        async function test() {
            return 1;
          }

          console.log(test());

14.  What is Promise.all, and what happens if one promise rejects?

15. Write a function wait(ms) that returns a Promise which resolves after ms milliseconds.

      wait(1000).then(() => console.log("1 second passed"));


16. Convert this callback-based function into a Promise:

      function fetchUser(callback) {
        setTimeout(() => {
          callback({ name: "John" });
        }, 1000);
      }

    
17. What is the difference between:

        Promise.all
        Promise.allSettled
        Promise.race
        Promise.any

        Explain real use cases.
--------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” async/await 

1. What is async/await, and why was it introduced in JavaScript?

2. What does the async keyword do to a function?

3. What happens if you await a non-Promise value?

4. Why must await only be used inside an async function?

5. What gets printed, and why?

    async function test() {
      return "Hello";
    }

    console.log(test());


6. What is the exact output order?

      async function f() {
        console.log(1);
        await Promise.resolve();
        console.log(2);
      }

      console.log(3);
      f();
      console.log(4);


7. What logs first?

    async function getData() {
      await new Promise(res => setTimeout(res, 1000));
      return 10;
    }

    getData().then(console.log);
    console.log("Done");

8. How do you handle errors in async/await?
    Show both try/catch and .catch() approaches.

9.  Will â€œAfterâ€ print? Why?

      async function test() {
          throw new Error("Oops");
        }

        test();
        console.log("After");

      
10. Why doesn't this catch the error?

      try {
        async function run() {
          throw new Error("Fail");
        }
        run();
      } catch (e) {
        console.log("Caught!");
      }

  
11. What logs and in what order?

      async function a() {
        console.log("A1");
        await b();
        console.log("A2");
      }

      async function b() {
        console.log("B1");
        return "B done";
      }

      a();

12.  What is the difference between:

      âœ”ï¸ awaiting multiple Promises sequentially
      âœ”ï¸ awaiting them in parallel with Promise.all

13. What prints and after how long?

      async function slow() {
        await new Promise(res => setTimeout(res, 2000));
        return "slow";
      }

      async function fast() {
        await new Promise(res => setTimeout(res, 500));
        return "fast";
      }

      async function run() {
        const s = slow();
        const f = fast();
        console.log(await f, await s);
      }

      run();


14. Why is .forEach not async-await friendly?

      [1,2,3].forEach(async (num) => {
        await wait(1000);
        console.log(num);
      });


15. Rewrite this code using async/await:

      fetchData()
        .then(processData)
        .then(saveData)
        .catch(handleError);

16. Why is await inside a loop often a performance issue?
      What is the better alternative? 

17.  What will be the output?

    async function test() {
        console.log("Start");

        const promise = new Promise((res) => {
          console.log("Inside Promise");
          res("Done");
        });

        console.log(await promise);
        console.log("End");
      }

      test();


18. Why should you almost always return inside a try block when using async/await?

19. What happens if you forget await before a Promise?

20. Create a sleep(ms) function using async/await:

      await sleep(2000);
      console.log("2 seconds passed");
--------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Currying function

1. What is currying in JavaScript? Explain in simple words with an example.

2. What is the main difference between currying and partial application?

3. Why is currying useful in functional programming?

4. What will this code print?

      function add(a) {
        return function (b) {
          return a + b;
        };
      }

      console.log(add(5)(3));


5. Write a simple curry function that converts: 
    
    function add(a, b, c) { return a + b + c; }

    into 

    curry(add)(1)(2)(3) // 6


6. What is the output?
    
    function multiply(a) {
        return function(b) {
          return function(c) {
            console.log(a * b * c);
          };
        };
      }

      multiply(2)(3)(4);


7.  Explain how currying helps in reusing functions.

      function log(type) {
          return function(message) {
            console.log(`[${type}] : ${message}`);
          };
        }


8. Convert this normal function into a curried version:

      function discount(price, percentage) {
          return price * (percentage / 100);
        }

    Expected output:

      const tenPercent = curriedDiscount(10);
      console.log(tenPercent(500)); // 50


9. What is the output?

      function sum(a) {
        return function(b) {
          if (b !== undefined) return sum(a + b);
          return a;
        };
      }

      console.log(sum(1)(2)(3)());


10. Why does currying help with functions that accept many arguments?

11. Why does this code fail?

      function add(a, b) {
          return a + b;
        }

        const curriedAdd = add(5);
        console.log(curriedAdd(10));

        Explain what the fix is.


12. Create a generic curry function that works for any number of arguments:

        function sum(a, b, c, d) { return a + b + c + d; }

        const curried = curry(sum);
        console.log(curried(1)(2)(3)(4)); // 10


13. What will the following code produce?

        function evaluate(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                console.log(a + b + c + d);
              };
            };
          };
        }

        evaluate(1)(2)(3)(4);


14. How does currying help with event handling?

    const handleEvent = (type) => (msg) => console.log(type, msg);

    document.addEventListener("click", () => handleEvent("CLICK")("Button pressed"));

15. Rewrite this function to support both styles:

    sum(1,2,3);   // 6  
    sum(1)(2)(3); // 6
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Debouncing

1. What is debouncing in JavaScript, and why do we use it? Explain using a real-world example (like typing in a search bar).

2. What is the difference between debouncing and throttling? Give one use case for each.

3. Write a basic debounce function that takes a callback and delay:

      function debounce(fn, delay) { /* your code */ }
 
        Explain how it works internally.

4. You have an input box and want to call an API only after the user stops typing for 500ms.
      How will you use debounce here?
      Write a small code snippet showing usage.

5. What happens in this scenario?

      const fn = () => console.log("API Call");
        const debounced = debounce(fn, 1000);

        debounced();
        debounced();
        debounced();

    How many times does "API Call" print, and why?


6. Why must we use clearTimeout inside a debounce function?
      Explain what happens if we don't.

7. Modify debounce so it supports an option:

      immediate: true

      Meaning:
      Run the function immediately at the first call, and then ignore calls until after the delay.

      Describe how youâ€™d add this feature.

8. Why is this debounce implementation incorrect?

      function debounce(fn, delay) {
          let timer;
          return function() {
            setTimeout(() => {
              fn();
            }, delay);
          };
        }

      Describe the specific bug and how to fix it.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Throttling

1. What is throttling in JavaScript, and why do we use it?
Explain using a real-world example (like scroll events or window resize).

2. Write a basic throttle function that ensures a callback runs at most once every delay milliseconds:

      function throttle(fn, delay) { /* your code */ }

      Explain the internal mechanism.

3. You want to run a function while a user scrolls, but not on every pixel movement â€” only once every 200ms.
      Show how you would use throttle in this situation.

4.  const fn = () => console.log("Scroll event");
      const throttled = throttle(fn, 1000);

      throttled();
      throttled();
      throttled();

      How many times does "Scroll event" print and why?


5. Types of Throttling

Explain the difference between:

Leading throttle
Trailing throttle

Which one fires the callback at the start, and which one at the end of the delay window?

6. Modify your throttle function so it supports both options:

      leading: true,
      trailing: false

      Explain how you would handle these scenarios.


7. Why is the following throttle implementation incorrect?

        function throttle(fn, delay) {
          let timer;
          return function() {
            if (!timer) {
              setTimeout(() => {
                fn();
              }, delay);
            }
          };
        }

    Describe the exact bug and how to fix it.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Event Bubbling

1. What is event bubbling in JavaScript?
Explain how an event moves through the DOM when a user clicks on a nested element.

2. Given the HTML:

      <div id="parent">
        <button id="child">Click me</button>
      </div>

    And JavaScript:

    document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked");
      });

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked");
      });

      If you click the button,
      what is the order of console logs and why?


3.   How does event.stopPropagation() affect event bubbling?
      Write a code snippet showing how to prevent the parent from receiving the event when the child is clicked.

4.   Why is event bubbling important for event delegation?
     Explain with an example where you handle clicks on multiple list items using a single event listener.

5.   Why does this code log both messages even after trying to stop bubbling?

      parent.addEventListener("click", () => console.log("Parent"));
        child.addEventListener("click", (e) => {
          console.log("Child");
          e.stopImmediatePropagation();
        });

        Explain what mistake was made and how to correctly prevent the parent's event from firing.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Event capturing/trickling

1. What is event capturing in JavaScript?
    Explain how events travel during the capturing phase before they bubble back up.

2.  Given the HTML:

      <div id="outer">
        <div id="middle">
          <button id="inner">Click</button>
        </div>
      </div>

    And JavaScript:

    outer.addEventListener("click", () => console.log("Outer"), true);
    middle.addEventListener("click", () => console.log("Middle"));
    inner.addEventListener("click", () => console.log("Inner"));

    If you click the button,
    what is the exact log order and why?

    (Hint: one uses capturing, others default to bubbling)


3.  Explain the difference between:

    element.addEventListener("click", handler, true);
      vs
    element.addEventListener("click", handler, false);

    Give one scenario where capturing is actually useful.

4.  Does event.stopPropagation() stop the capturing phase, bubbling phase, or both?
      Explain with a small code example.

5.  Why does this code still log "Parent" even though the child listener is in the capturing phase?

      parent.addEventListener("click", () => console.log("Parent"), true);

      child.addEventListener("click", (e) => {
        console.log("Child");
        e.stopPropagation();
      }, true);

      Explain what is happening, and how to make sure only the child logs.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Event Delegation

1.  What is event delegation in JavaScript, and why do we use it?
      Explain using a real-world example (such as clicking multiple list items with one event listener).

2.  Given this HTML:

      <ul id="menu">
        <li class="item">Home</li>
        <li class="item">About</li>
        <li class="item">Contact</li>
      </ul>

    Write JavaScript code using event delegation so that clicking any <li> logs its text content.

3.  What is the difference between event.target and event.currentTarget in event delegation?
      Explain with an example of a nested HTML structure.

4.  Why is event delegation better for performance when dealing with a large number of dynamically created DOM elements?
    Give a practical scenario where delegation is the only scalable option.

5.  Why does the following event delegation fail to log anything?

      document.getElementById("list").addEventListener("click", (e) => {
          if (e.target === "li") {
            console.log("Clicked:", e.target.textContent);
          }
        });

      Identify the bug and explain how to fix it.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ðŸ¤” Event propogation

1.  What is event propagation in JavaScript?
    Explain the three phases of event propagation:

    Capturing (trickling)
    Target
    Bubbling

    Provide a simple example to demonstrate the full flow.

2. Given this HTML:

    <div id="grandparent">
      <div id="parent">
        <button id="child">Click</button>
      </div>
    </div>

    And JavaScript:

    grandparent.addEventListener("click", () => console.log("Grandparent Capture"), true);
    parent.addEventListener("click", () => console.log("Parent Bubble"));
    child.addEventListener("click", () => console.log("Child Target"));

    If the user clicks the button,
    what is the exact log order and why?


3.  What is the difference between stopPropagation() and stopImmediatePropagation()?

    Give an example where both listeners are on the same element, and only one method prevents the second from firing.

4.  If an event listener calls event.stopPropagation() inside the capturing phase, does it prevent:

    only bubbling?
    only capturing?
    or both?

    Explain with a code snippet.

5.  Why does this code still trigger the parent click event even though we are trying to stop propagation?

    parent.addEventListener("click", () => console.log("Parent clicked"));
    child.addEventListener("click", (e) => {
      console.log("Child clicked");
      e.stopPropagation();
    });
    child.innerHTML = "<span>Click me</span>";

    Clicking the <span> logs:

    Child clicked
    Parent clicked

    Explain what is happening and how to correctly stop propagation.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------






